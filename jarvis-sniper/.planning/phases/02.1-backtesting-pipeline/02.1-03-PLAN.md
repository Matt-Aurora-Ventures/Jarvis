---
phase: 02.1-backtesting-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - src/stores/useSniperStore.ts
  - src/app/api/backtest/route.ts
autonomous: true

must_haves:
  truths:
    - "All 18 strategy presets produce validation reports with real metrics (win rate, profit factor, max drawdown, Sharpe ratio, expectancy)"
    - "Memecoin strategies are tested against graduation-calibrated synthetic data"
    - "Blue chip strategies are tested against real OHLCV data (from hardened data pipeline)"
    - "Underperforming strategies (win rate < 40% OR profit factor < 1.0) are flagged in the preset definition"
    - "Preset win rate strings reflect backtested reality, not estimates"
    - "API response includes per-strategy 'validated' flag distinguishing backtested from estimated presets"
  artifacts:
    - path: "src/stores/useSniperStore.ts"
      provides: "Updated STRATEGY_PRESETS with backtested win rates and validation metadata"
      contains: "backtested"
    - path: "src/app/api/backtest/route.ts"
      provides: "Enhanced backtest API with memecoin graduation data support and validation flags"
      contains: "generateMemeGraduationCandles"
  key_links:
    - from: "src/app/api/backtest/route.ts"
      to: "src/lib/historical-data.ts"
      via: "import generateMemeGraduationCandles"
      pattern: "import.*generateMemeGraduationCandles.*historical-data"
    - from: "src/app/api/backtest/route.ts"
      to: "src/lib/backtest-engine.ts"
      via: "BacktestEngine import"
      pattern: "import.*BacktestEngine.*backtest-engine"
    - from: "src/stores/useSniperStore.ts"
      to: "strategy presets"
      via: "STRATEGY_PRESETS array with backtested metadata"
      pattern: "backtested.*true|validated"
---

<objective>
Wire the backtest API to use real/hardened data sources for all 18 strategies, add memecoin graduation data support, and update strategy presets with validated win rate metadata.

Purpose: The backtest API currently uses server-side synthetic candles for all runs. After Plan 01 hardens the data pipeline, this plan connects the API to real data sources for blue chips and graduation-calibrated data for memecoins. It also adds validation metadata to strategy presets so the UI can distinguish backtested from estimated win rates.

Output: Enhanced `/api/backtest` route using hardened data sources, updated `STRATEGY_PRESETS` with backtested metadata fields, and underperformer flagging.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02.1-backtesting-pipeline/02.1-01-SUMMARY.md
@src/app/api/backtest/route.ts
@src/stores/useSniperStore.ts (lines 1-30 for types, lines 28-287 for STRATEGY_PRESETS)
@src/lib/historical-data.ts
@src/lib/backtest-engine.ts (lines 62-99 for BacktestResult)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance backtest API route with hardened data sources and memecoin graduation support</name>
  <files>src/app/api/backtest/route.ts</files>
  <action>
Update the backtest API route to use the hardened data pipeline from Plan 01 instead of server-side synthetic candles. Add memecoin graduation data support.

Implementation:

1. Import from historical-data.ts:
   ```typescript
   import { fetchTokenHistory, generateMemeGraduationCandles } from '@/lib/historical-data';
   import { ALL_BLUECHIPS } from '@/lib/bluechip-data';
   ```

2. Replace the `generateServerCandles()` function usage with real data fetching:
   - For blue chip strategies (`bluechip_mean_revert`, `bluechip_trend_follow`, `bluechip_breakout`): Call `fetchTokenHistory(token)` for each blue chip token. This uses the 3-tier fallback (DexScreener -> Birdeye -> synthetic).
   - For memecoin strategies (`pump_fresh_tight`, `momentum`, `insight_j`, `micro_cap_surge`, `elite`, `hybrid_b`, `let_it_ride`, `loose`, `genetic_best`, `genetic_v2`): Call `generateMemeGraduationCandles(200)` and run each memecoin strategy against the set of graduation patterns. Aggregate results across all graduation tokens. (Note: 200 synthetic-calibrated tokens with 4 pattern archetypes produce 800+ strategy-vs-pattern test cases — sufficient for validation. See Plan 01 for detailed rationale on synthetic vs real data.)
   - For xStock/index/prestock strategies (`xstock_intraday`, `xstock_swing`, `prestock_speculative`, `index_intraday`, `index_leveraged`): Keep using `generateServerCandles()` with their respective volatility profiles (these are tokenized equities — no real historical data available from DexScreener/Birdeye for them).

3. Add a `validated` field to each result summary:
   ```typescript
   validated: data.source !== 'synthetic',  // true if real data used
   ```

4. Add a `dataSource` field to each result:
   ```typescript
   dataSource: data.source,  // 'dexscreener' | 'birdeye' | 'synthetic'
   ```

5. Add underperformer detection to the response:
   ```typescript
   const underperformers = results.filter(r =>
     r.winRate < 0.40 || r.profitFactor < 1.0
   ).map(r => r.strategyId);
   ```
   Include `underperformers` array in the JSON response.

6. Keep the existing `generateServerCandles()` function for xStock/index fallback — do NOT remove it.

7. **Add the 7 missing strategies to STRATEGY_CONFIGS.** The current STRATEGY_CONFIGS only maps 11 of 18 presets. Add these missing entries derived from their STRATEGY_PRESETS definitions in `useSniperStore.ts`:
   ```typescript
   elite: {
     strategyId: 'elite',
     stopLossPct: 15, takeProfitPct: 60, trailingStopPct: 8,
     minScore: 0, minLiquidityUsd: 100000,
     slippagePct: 0.5, feePct: 0.25,
     maxHoldCandles: 8,
   },
   hybrid_b: {
     strategyId: 'hybrid_b',
     stopLossPct: 20, takeProfitPct: 60, trailingStopPct: 8,
     minScore: 0, minLiquidityUsd: 50000,
     slippagePct: 0.5, feePct: 0.25,
     maxHoldCandles: 8,
   },
   let_it_ride: {
     strategyId: 'let_it_ride',
     stopLossPct: 20, takeProfitPct: 100, trailingStopPct: 5,
     minScore: 0, minLiquidityUsd: 50000,
     slippagePct: 0.5, feePct: 0.25,
     maxHoldCandles: 24,
   },
   loose: {
     strategyId: 'loose',
     stopLossPct: 20, takeProfitPct: 60, trailingStopPct: 8,
     minScore: 0, minLiquidityUsd: 25000,
     slippagePct: 0.5, feePct: 0.25,
     maxHoldCandles: 8,
   },
   genetic_best: {
     strategyId: 'genetic_best',
     stopLossPct: 35, takeProfitPct: 200, trailingStopPct: 12,
     minScore: 43, minLiquidityUsd: 3000,
     slippagePct: 1.0, feePct: 0.25,
     maxHoldCandles: 24,
   },
   genetic_v2: {
     strategyId: 'genetic_v2',
     stopLossPct: 45, takeProfitPct: 207, trailingStopPct: 10,
     minScore: 0, minLiquidityUsd: 5000,
     slippagePct: 1.0, feePct: 0.25,
     maxHoldCandles: 24,
   },
   prestock_speculative: {
     strategyId: 'prestock_speculative',
     stopLossPct: 5, takeProfitPct: 15, trailingStopPct: 3,
     minScore: 30, minLiquidityUsd: 5000,
     slippagePct: 0.3, feePct: 0.25,
     maxHoldCandles: 120,
   },
   ```
   All 7 missing strategies are memecoin or prestock types. Their entry signals fall through to `momentumEntry` as default (acceptable — see WARNING 1 note below).

   **Note on ENTRY_SIGNALS fallback:** Only 7 strategies have specific entry signals; the remaining 11 use `momentumEntry` as fallback. This is technically valid but may produce somewhat generic backtest results for strategies designed around different entry logic (e.g., mean reversion for `elite`). This is acceptable for initial validation — a future plan can add specialized entry signals per strategy if backtest results reveal the fallback is misleading.

8. Handle the async nature of `fetchTokenHistory()` — the current loop is sync with `generateServerCandles()`. Wrap the token loop in `Promise.all` with concurrency limit (batch 3 at a time to avoid rate limits):
   ```typescript
   // Process tokens in batches of 3
   for (let batch = 0; batch < tokens.length; batch += 3) {
     const batchTokens = tokens.slice(batch, batch + 3);
     const batchData = await Promise.all(
       batchTokens.map(token => fetchTokenHistory(token))
     );
     // ... run backtest for each token in batch
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` — 0 errors.
Grep for `fetchTokenHistory` and `generateMemeGraduationCandles` in route.ts.
Grep for `validated` and `underperformers` in route.ts.
Grep for `elite`, `hybrid_b`, `let_it_ride`, `loose`, `genetic_best`, `genetic_v2`, `prestock_speculative` in route.ts — all 7 must be present in STRATEGY_CONFIGS.
Count total keys in STRATEGY_CONFIGS — must be 18.
  </verify>
  <done>
Backtest API uses real OHLCV data for blue chips via hardened pipeline, graduation-calibrated data for memecoins, and synthetic data for xStocks/indexes. All 18 strategy presets have entries in STRATEGY_CONFIGS (not just the original 11). Response includes `validated` flag and `underperformers` array. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add backtest validation metadata to strategy presets</name>
  <files>src/stores/useSniperStore.ts</files>
  <action>
Extend the `StrategyPreset` interface and `STRATEGY_PRESETS` array to support backtested validation metadata. This allows the UI to distinguish between estimated and validated win rates.

Implementation:

1. Extend the `StrategyPreset` interface with optional backtest fields:
   ```typescript
   export interface StrategyPreset {
     id: string;
     name: string;
     description: string;
     winRate: string;
     trades: number;
     config: Partial<SniperConfig>;
     assetType?: AssetType;
     /** Set to true after this strategy has been backtested with real/calibrated data */
     backtested?: boolean;
     /** If backtested, the data source used ('dexscreener' | 'birdeye' | 'synthetic-calibrated') */
     dataSource?: string;
     /** If backtested and win rate < 40% or profit factor < 1.0 */
     underperformer?: boolean;
   }
   ```

2. Update the three blue chip strategy presets to include initial backtest metadata (these will be updated by the UI after running):
   - `bluechip_mean_revert`: Add `backtested: false`
   - `bluechip_trend_follow`: Add `backtested: false`
   - `bluechip_breakout`: Add `backtested: false`
   - All memecoin presets: Add `backtested: false`
   - All xStock/index presets: Add `backtested: false`

3. Add a Zustand action `updatePresetBacktestResults(results: Array<{ strategyId: string; winRate: string; trades: number; backtested: boolean; dataSource: string; underperformer: boolean }>)` that:
   - Iterates over results
   - Finds matching preset by `strategyId`
   - Updates: `winRate`, `trades`, `backtested`, `dataSource`, `underperformer`
   - This is called by the UI after a backtest run completes

4. The action should update the persisted Zustand state (already using `persist` middleware), so backtest results survive page reload.

5. Do NOT change existing preset configs (SL/TP/trailing values). Only add the new metadata fields and the update action.

6. Do NOT modify the `STRATEGY_PRESETS` const array values — the defaults stay as-is. The Zustand action updates are runtime-only and persisted via localStorage. The const array serves as the initial default.

  Wait — `STRATEGY_PRESETS` is a const array, not in the Zustand store. The store holds config but not the preset definitions. To make this work cleanly:
   - Add a `backtestMeta: Record<string, { winRate: string; trades: number; backtested: boolean; dataSource: string; underperformer: boolean }>` field to the Zustand store state (not the presets array).
   - Add the `updatePresetBacktestResults` action that writes to `backtestMeta`.
   - Export a helper function `getPresetWithMeta(presetId: string)` that merges `STRATEGY_PRESETS` with `backtestMeta` overlay.
   - Initialize `backtestMeta` as `{}` (empty — populated after first backtest run).
   - This approach doesn't modify the const STRATEGY_PRESETS and uses Zustand persistence.
  </action>
  <verify>
Run `npx tsc --noEmit` — 0 errors.
Grep for `backtestMeta` and `updatePresetBacktestResults` in useSniperStore.ts.
Grep for `getPresetWithMeta` in useSniperStore.ts.
  </verify>
  <done>
StrategyPreset interface extended with backtest metadata fields. Zustand store has `backtestMeta` state and `updatePresetBacktestResults` action. `getPresetWithMeta()` helper merges const presets with runtime backtest data. TypeScript compiles clean. Persisted via Zustand persist middleware.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — 0 TypeScript errors
2. `npx next build` — successful build
3. API route uses real data for blue chips, graduation data for memecoins
4. Response includes `validated` flag and `underperformers` array
5. Store has `backtestMeta` state that persists across sessions
6. `getPresetWithMeta()` merges const presets with runtime data
</verification>

<success_criteria>
- All 18 strategies have entries in STRATEGY_CONFIGS and can produce validation reports via the API
- Blue chip strategies use real OHLCV data (3-tier fallback)
- Memecoin strategies use graduation-calibrated synthetic data
- Underperforming strategies identified in API response
- Store persists backtest results so they survive page reload
- getPresetWithMeta() overlays real backtested metrics on preset defaults
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-backtesting-pipeline/02.1-03-SUMMARY.md`
</output>
