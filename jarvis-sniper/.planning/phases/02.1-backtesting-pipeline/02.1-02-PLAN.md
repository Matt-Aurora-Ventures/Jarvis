---
phase: 02.1-backtesting-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useBacktest.ts
  - src/components/BacktestPanel.tsx
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger a backtest run from the UI by selecting a strategy and clicking Run"
    - "Progress indicator shows which strategy/token is currently being tested"
    - "Backtest results display win rate, profit factor, Sharpe ratio, max drawdown, and expectancy for each strategy"
    - "Results persist in localStorage so they survive page refresh"
    - "User can see which strategies are validated vs still using estimated win rates"
  artifacts:
    - path: "src/hooks/useBacktest.ts"
      provides: "React hook for backtest state management and API calls"
      exports: ["useBacktest"]
    - path: "src/components/BacktestPanel.tsx"
      provides: "Backtest dashboard UI with run controls and results table"
      exports: ["BacktestPanel"]
    - path: "src/app/page.tsx"
      provides: "Main page with BacktestPanel integrated"
      contains: "BacktestPanel"
  key_links:
    - from: "src/hooks/useBacktest.ts"
      to: "/api/backtest"
      via: "fetch POST"
      pattern: "fetch.*api/backtest"
    - from: "src/hooks/useBacktest.ts"
      to: "src/stores/useSniperStore.ts"
      via: "useSniperStore.getState().updatePresetBacktestResults"
      pattern: "updatePresetBacktestResults"
    - from: "src/components/BacktestPanel.tsx"
      to: "src/hooks/useBacktest.ts"
      via: "useBacktest() hook import"
      pattern: "import.*useBacktest"
    - from: "src/app/page.tsx"
      to: "src/components/BacktestPanel.tsx"
      via: "component import"
      pattern: "import.*BacktestPanel"
---

<objective>
Build the backtest dashboard UI so users can trigger strategy validation runs, monitor progress, and view results with key performance metrics.

Purpose: The backtest engine and API route exist but there's no way to trigger or view results from the UI. Without this, backtesting is API-only and invisible to users. The dashboard makes strategy validation transparent and gives users confidence in the claimed win rates.

Output: `useBacktest` hook, `BacktestPanel` component, and integration into the main page.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/page.tsx
@src/app/api/backtest/route.ts
@src/stores/useSniperStore.ts (lines 1-30 for StrategyPreset type, lines 28-287 for STRATEGY_PRESETS)
@src/lib/backtest-engine.ts (lines 62-99 for BacktestResult type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBacktest hook for backtest state and API interaction</name>
  <files>src/hooks/useBacktest.ts</files>
  <action>
Create a new React hook `useBacktest` that manages backtest execution state and communicates with the existing `/api/backtest` POST endpoint.

Implementation:

1. Define local state interfaces:
   ```typescript
   interface BacktestRunState {
     isRunning: boolean;
     progress: { current: number; total: number; currentStrategy: string } | null;
     results: BacktestSummary[] | null;
     report: string | null;
     error: string | null;
     lastRunAt: number | null;
   }

   interface BacktestSummary {
     strategyId: string;
     token: string;
     trades: number;
     winRate: string;
     profitFactor: string;
     sharpe: string;
     maxDD: string;
     expectancy: string;
     avgHold: string;
   }
   ```

2. Hook implementation:
   - `useBacktest()` returns: `{ state, runBacktest, runAllStrategies, clearResults }`
   - Use `useState` for `BacktestRunState`
   - `runBacktest(strategyId: string, mode: 'quick' | 'full' | 'grid')`:
     - Sets `isRunning: true`, clears error
     - Calls `POST /api/backtest` with `{ strategyId, mode }`
     - On success: sets results + report, `isRunning: false`
     - On error: sets error message, `isRunning: false`
   - `runAllStrategies()`:
     - Calls `runBacktest('all', 'quick')` for a fast overview
   - `clearResults()`: resets state

3. Persist results in localStorage under key `jarvis_backtest_results`:
   - On successful run, save `{ results, report, lastRunAt }` to localStorage
   - On hook mount, load cached results from localStorage as initial state
   - This allows results to survive page refresh

4. Import types from existing modules:
   - Import `STRATEGY_PRESETS` from `@/stores/useSniperStore` (for strategy list)
   - Import `useSniperStore` from `@/stores/useSniperStore` (for Zustand store access)
   - Do NOT import BacktestResult directly — use the summary format returned by the API

5. **Wire to Zustand store (critical):** After a successful backtest API response, call the Zustand `updatePresetBacktestResults` action to persist validated metrics into the store. This is the bridge between the backtest hook and the strategy preset metadata:
   ```typescript
   // Inside runBacktest(), after setting results on success:
   const updatePresets = useSniperStore.getState().updatePresetBacktestResults;
   if (updatePresets && data.results) {
     updatePresets(data.results.map((r: BacktestSummary) => ({
       strategyId: r.strategyId,
       winRate: r.winRate,
       trades: r.trades,
       backtested: true,
       dataSource: r.dataSource || 'synthetic',
       underperformer: parseFloat(r.winRate) < 40 || parseFloat(r.profitFactor) < 1.0,
     })));
   }
   ```
   This ensures Plan 03's `backtestMeta` state gets populated when the user runs a backtest from the UI.

**Dependency note:** This hook calls `/api/backtest` which uses `historical-data.ts` from Plan 01. If Plan 01 changes the `HistoricalDataSet` type shape, the API response format may change. The hook relies on the summary shape returned by the API (not the raw types), so it is resilient to internal type changes. However, if Plan 01 adds new fields to the API response (e.g., `dataSource`, `validated`), Plan 02 should propagate them. The `BacktestSummary` interface should include optional `dataSource?: string` and `validated?: boolean` fields to be forward-compatible with Plan 03's enhancements.

Export the hook as named export: `export function useBacktest()`.
  </action>
  <verify>
Run `npx tsc --noEmit` — 0 errors.
Grep for `useBacktest` in the file to confirm export exists.
  </verify>
  <done>
`useBacktest` hook exported with `runBacktest`, `runAllStrategies`, `clearResults`. Results cached in localStorage. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BacktestPanel component and integrate into main page</name>
  <files>src/components/BacktestPanel.tsx, src/app/page.tsx</files>
  <action>
Create a BacktestPanel component that displays backtest controls and results, then add it to the main trading dashboard page.

**BacktestPanel.tsx implementation:**

1. Create a collapsible panel component styled to match the existing trading terminal dark theme (use the same Tailwind patterns as `StatusBar.tsx` and `PositionsPanel` — dark backgrounds, green/red for P&L, monospace for numbers).

2. Panel sections:
   a. **Header bar:** "STRATEGY VALIDATION" title + collapse/expand toggle + "Run All" button
   b. **Strategy selector:** Dropdown listing all 18 strategies from `STRATEGY_PRESETS` + "All Strategies" option
   c. **Mode selector:** Quick / Full (walk-forward) / Grid (parameter search) — 3 radio buttons
   d. **Run button:** Triggers `runBacktest()` or `runAllStrategies()`. Disabled when running. Shows spinner when active.
   e. **Progress indicator:** When running, show "Testing {currentStrategy}... ({current}/{total})"
   f. **Results table:** Monospace table with columns:
      - Strategy | Token | Trades | Win Rate | Profit Factor | Sharpe | Max DD | Expectancy | Avg Hold
      - Color-code win rates: green >= 55%, yellow 45-55%, red < 45%
      - Color-code Sharpe: green >= 1.0, yellow 0.5-1.0, red < 0.5
   g. **Underperformer flag:** Strategies with win rate < 40% OR profit factor < 1.0 get a red "UNDERPERFORMER" badge
   h. **Last run timestamp:** "Last validated: {date}" at bottom of panel

3. Use `useBacktest()` hook for all state management.

4. If `results` is null (never run), show: "No backtest data. Click 'Run All' to validate strategies against historical data."

**page.tsx integration:**

5. Import `BacktestPanel` in `src/app/page.tsx`.

6. Add `<BacktestPanel />` after the existing `PerformanceSummary` component (before closing tags), wrapped in a section with the same grid styling used by adjacent panels.

7. The panel should be collapsed by default (only header visible) to not overwhelm the main trading view.

Match existing code style: 'use client' directive, Tailwind classes, dark theme colors (bg-zinc-900, border-zinc-700, text-zinc-300, etc.).
  </action>
  <verify>
Run `npx tsc --noEmit` — 0 errors.
Run `npm run build` (or `npx next build`) — verify no build errors.
Verify BacktestPanel is imported and rendered in page.tsx.
  </verify>
  <done>
BacktestPanel renders with strategy selector, mode selector, run controls, results table with color-coded metrics, and underperformer flagging. Panel is collapsible and integrated into the main page. Build succeeds with 0 errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — 0 TypeScript errors
2. `npx next build` — successful build
3. BacktestPanel visible on page (collapsed by default)
4. Clicking "Run All" triggers POST to /api/backtest
5. Results table displays after run completes
6. Results persist across page refresh (localStorage)
7. Underperforming strategies flagged with red badge
</verification>

<success_criteria>
- Users can trigger backtest from the UI (strategy selector + run button)
- Progress shows during execution
- Results table displays all key metrics (WR, PF, Sharpe, DD, Expectancy)
- Underperforming strategies visually flagged
- Results cached in localStorage across sessions
- Build passes with 0 errors
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-backtesting-pipeline/02.1-02-SUMMARY.md`
</output>
