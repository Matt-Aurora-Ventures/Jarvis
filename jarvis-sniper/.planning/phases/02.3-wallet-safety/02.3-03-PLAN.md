---
phase: 02.3-wallet-safety
plan: 03
type: execute
wave: 2
depends_on: ["02.3-01", "02.3-02"]
files_modified:
  - src/components/FundRecoveryBanner.tsx
  - src/lib/session-wallet.ts
  - src/stores/useSniperStore.ts
autonomous: false

must_haves:
  truths:
    - "Dev server starts without errors and main page renders FundRecoveryBanner without crash"
    - "Circuit breaker per-asset isolation verified: tripping memecoin breaker does not block blue chip snipe guard"
    - "Cooldown auto-reset verified: after cooldown expires, snipe guard allows trades for that asset class again"
    - "Network failure during sweep is handled gracefully (no unhandled promise rejection, wallet key persists)"
    - "Tab close scenario: beforeunload fires sweep attempt, wallet key persists in localStorage regardless"
  artifacts:
    - path: "src/lib/session-wallet.ts"
      provides: "Network timeout on sweepToMainWalletFireAndForget, error boundary for RPC failures"
    - path: "src/components/FundRecoveryBanner.tsx"
      provides: "Error states for network failure during recovery sweep"
    - path: "src/stores/useSniperStore.ts"
      provides: "Verified per-asset isolation logic"
  key_links:
    - from: "src/lib/session-wallet.ts sweepToMainWalletFireAndForget"
      to: "Solana RPC"
      via: "connection.sendRawTransaction with AbortSignal timeout"
      pattern: "AbortSignal|timeout|signal"
    - from: "src/stores/useSniperStore.ts snipeToken guard"
      to: "circuitBreaker.perAsset cooldownUntil"
      via: "Date.now() >= cooldownUntil check before allowing snipe"
      pattern: "cooldownUntil"
---

<objective>
Integration testing, edge case hardening, and visual verification of wallet safety and circuit breaker features.

Purpose: Plans 01 and 02 implement the core features. This plan hardens edge cases (network failure during sweep, RPC timeout, tab crash scenarios) and verifies the complete integration works end-to-end. Critical because fund safety code that fails silently is worse than no safety code at all.

Output: Hardened error handling, verified circuit breaker isolation, and human-verified UI working correctly.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.3-wallet-safety/02.3-01-SUMMARY.md
@.planning/phases/02.3-wallet-safety/02.3-02-SUMMARY.md

Key existing files:
@src/lib/session-wallet.ts — Hardened auto-sweep from Plan 01
@src/components/FundRecoveryBanner.tsx — Fund recovery UI from Plan 01
@src/stores/useSniperStore.ts — Per-asset circuit breakers from Plan 02
@src/components/SniperControls.tsx — Per-asset UI from Plan 02
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden edge cases — network timeout, RPC failure, error boundaries</name>
  <files>src/lib/session-wallet.ts, src/components/FundRecoveryBanner.tsx</files>
  <action>
**1. Add AbortSignal timeout to sweepToMainWalletFireAndForget**

In `src/lib/session-wallet.ts`, update `sweepToMainWalletFireAndForget` to add a 10-second timeout on both the getBalance call and the blockhash fetch. This prevents the beforeunload handler from hanging if the RPC is slow:

```typescript
export async function sweepToMainWalletFireAndForget(
  sessionKeypair: Keypair,
  mainWallet: string,
): Promise<void> {
  try {
    const connection = new Connection(RPC_URL, { commitment: 'confirmed' });

    // Use Promise.race with timeout — beforeunload won't wait for slow RPC
    const TIMEOUT_MS = 5_000; // 5 seconds max for teardown sweep
    const timeoutPromise = new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('sweep timeout')), TIMEOUT_MS)
    );

    const balance = await Promise.race([
      connection.getBalance(sessionKeypair.publicKey),
      timeoutPromise,
    ]);

    const FEE_BUFFER_LAMPORTS = 30_000;
    const sweepAmount = balance - FEE_BUFFER_LAMPORTS;
    if (sweepAmount <= 0) return;

    const blockhash = await Promise.race([
      connection.getLatestBlockhash('confirmed'),
      timeoutPromise,
    ]);

    const instruction = SystemProgram.transfer({
      fromPubkey: sessionKeypair.publicKey,
      toPubkey: new PublicKey(mainWallet),
      lamports: sweepAmount,
    });

    const messageV0 = new TransactionMessage({
      payerKey: sessionKeypair.publicKey,
      recentBlockhash: blockhash.blockhash,
      instructions: [instruction],
    }).compileToV0Message();

    const tx = new VersionedTransaction(messageV0);
    tx.sign([sessionKeypair]);

    // Fire and forget — no await on confirm
    connection.sendRawTransaction(tx.serialize(), {
      skipPreflight: true,
      preflightCommitment: 'confirmed',
    }).catch(() => {});
  } catch {
    // Silently fail — wallet key persists in localStorage for recovery
  }
}
```

**2. Add error boundary handling to FundRecoveryBanner**

In `src/components/FundRecoveryBanner.tsx`, ensure:

- `checkForRecoverableWallet()` call is wrapped in try/catch (handles RPC being down on startup)
- If RPC is unreachable during startup check, show a softer message: "Could not check for recoverable wallets. If you had a session wallet, try again when network is available."
- The sweep button handler catches network errors and shows: "Sweep failed: {error}. Your funds are safe — the wallet key is preserved. Try again or use Manual Recovery in Settings."
- Add a retry button after sweep failure
- Ensure no unhandled promise rejections anywhere in the component

**3. Verify registerAutoSweep cleanup is correct**

In `registerAutoSweep`, ensure the visibilitychange listener is also cleaned up properly in the returned cleanup function:

```typescript
const visibilityHandler = () => {
  if (document.visibilityState === 'hidden') {
    handler();
  }
};
window.addEventListener('visibilitychange', visibilityHandler);

return () => {
  clearInterval(refreshInterval);
  window.removeEventListener('beforeunload', handler);
  window.removeEventListener('pagehide', handler);
  window.removeEventListener('visibilitychange', visibilityHandler);
};
```

**4. Verify store migration handles all edge cases**

In `src/stores/useSniperStore.ts`, verify the Zustand persist migration:
- If `perAssetBreakerConfig` is partially set (e.g., only memecoin defined), fill in missing asset types from DEFAULT_CONFIG
- If `cooldownUntil` is `undefined` on any existing AssetClassBreaker, set to 0
- If a user had tripped breakers before this update, they should still show as tripped (don't accidentally reset)

The migration should look like:
```typescript
// Ensure all asset types have config
const defaultPAC = DEFAULT_CONFIG.perAssetBreakerConfig;
if (state.config.perAssetBreakerConfig) {
  for (const k of Object.keys(defaultPAC) as AssetType[]) {
    if (!state.config.perAssetBreakerConfig[k]) {
      state.config.perAssetBreakerConfig[k] = defaultPAC[k];
    }
  }
} else {
  state.config.perAssetBreakerConfig = defaultPAC;
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` from the jarvis-sniper directory. Zero type errors.
Run `npm run build` (or `npx next build`) to verify no build errors.
Verify `sweepToMainWalletFireAndForget` has 5-second timeout.
Verify FundRecoveryBanner handles RPC errors gracefully (no unhandled rejections).
Verify registerAutoSweep cleanup removes all 3 event listeners.
  </verify>
  <done>
sweepToMainWalletFireAndForget has 5-second timeout for beforeunload context. FundRecoveryBanner catches all network errors with user-friendly messages and retry option. registerAutoSweep cleanup handles all event listeners. Store migration handles partial perAssetBreakerConfig and missing cooldownUntil.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete wallet safety and circuit breaker system:
1. Fire-and-forget auto-sweep on tab close (beforeunload + pagehide + visibilitychange)
2. FundRecoveryBanner on main page (detects orphaned session wallets on startup)
3. Per-asset circuit breakers with independent limits per asset class
4. Auto-cooldown timers on tripped breakers
5. Per-asset breaker status + configuration UI in SniperControls
  </what-built>
  <how-to-verify>
Start the dev server: `cd jarvis-sniper && npm run dev`
Open http://localhost:3001

**1. Verify FundRecoveryBanner:**
- If you have no session wallet with funds, the banner should NOT appear (invisible)
- If you have an orphaned session wallet (from previous testing), a warning banner should appear at top of page

**2. Verify Per-Asset Circuit Breaker UI:**
- Open the Sniper Controls panel
- Scroll to the Circuit Breaker section
- Verify you see per-asset breaker status (5 asset types: Memecoin, Blue Chip, xStock, Index, PreStock)
- All should show green/OK status with 0 consecutive losses
- Expand "Per-Asset Limits" section
- Verify configurable inputs for each asset type (Max Losses, Daily Limit, Cooldown)
- Try changing memecoin max losses to 2 — value should persist

**3. Verify Asset Isolation (conceptual):**
- The per-asset config should show different defaults: memecoin=3 losses, bluechip=5 losses
- This proves memecoin losses won't cascade to blue chip trading

**4. Verify build:**
- `npm run build` should complete without errors

Type "approved" if everything looks correct, or describe any issues.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. Dev server starts and renders main page without errors
4. FundRecoveryBanner self-hides when no recoverable wallet exists
5. Per-asset breaker status visible in SniperControls
6. Per-class limits configurable and persisted
7. No unhandled promise rejections in browser console
8. sweepToMainWalletFireAndForget has timeout protection
</verification>

<success_criteria>
- Edge cases hardened: network timeout, RPC failure, partial migration all handled
- No unhandled promise rejections anywhere in wallet safety code
- Build passes cleanly
- Human verifies: UI renders correctly, per-asset breakers visible, limits configurable
- Fund safety: even if every edge case fires, wallet key persists and recovery path works
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-wallet-safety/02.3-03-SUMMARY.md`
</output>
