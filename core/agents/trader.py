"""
Trader Agent - Crypto strategy, backtesting, risk management.

Capabilities:
- Crypto market data ingestion
- Strategy backtesting
- Paper trading
- Risk-constrained live execution (opt-in)

Uses Claude/GPT for quality decisions, with Ollama fallback.
This is the PRIMARY REVENUE GENERATOR for the economic loop.
"""

import json
import re
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from core import config, liquidation_bot, solana_scanner, trading_pipeline
from core.agents.base import (
    BaseAgent,
    AgentRole,
    AgentCapability,
    AgentTask,
    AgentResult,
    ProviderPreference,
)


ROOT = Path(__file__).resolve().parents[2]
TRADER_DIR = ROOT / "data" / "trader"
STRATEGIES_FILE = TRADER_DIR / "strategies.json"
PAPER_TRADES_FILE = TRADER_DIR / "paper_trades.jsonl"
BACKTEST_RESULTS = TRADER_DIR / "backtests.jsonl"


class TradingMode(str, Enum):
    RESEARCH = "research"       # Gathering data, analyzing
    BACKTEST = "backtest"       # Testing strategy on historical data
    PAPER = "paper"             # Simulated live trading
    LIVE = "live"               # Real money (requires explicit opt-in)
    STATUS = "status"           # Performance summary
    LIQUIDATION = "liquidation" # Liquidation sweep strategy
    SOLANA_SCAN = "solana_scan" # Solana meme coin scanner


@dataclass
class Strategy:
    """A trading strategy."""
    id: str
    name: str
    description: str
    rules: Dict[str, Any]
    created_at: float = field(default_factory=time.time)
    backtest_results: Optional[Dict] = None
    paper_results: Optional[Dict] = None
    approved_for_live: bool = False


@dataclass
class TradeSignal:
    """A trading signal generated by strategy."""
    strategy_id: str
    symbol: str
    direction: str  # "long" or "short"
    entry_price: float
    stop_loss: float
    take_profit: float
    size: float  # Position size as fraction of portfolio
    confidence: float
    timestamp: float = field(default_factory=time.time)


@dataclass
class BacktestResult:
    """Results from backtesting a strategy."""
    strategy_id: str
    period: str  # e.g., "2024-01-01 to 2024-12-01"
    total_trades: int
    win_rate: float
    profit_factor: float
    max_drawdown: float
    sharpe_ratio: float
    expectancy: float
    notes: str = ""


class TraderAgent(BaseAgent):
    """
    Trader Agent - Crypto research, strategy, and execution.

    This is the PRIMARY REVENUE ENGINE for Jarvis's economic loop.

    Pipeline stages:
    1. RESEARCH: Data ingestion, market analysis
    2. STRATEGY: Hypothesis formation, rule definition
    3. BACKTEST: Historical testing with metrics
    4. PAPER: Simulated live trading
    5. LIVE: Constrained real execution (opt-in only)

    Uses Claude/GPT for quality decisions (financial stakes),
    with Ollama fallback for self-sufficient operation.
    """

    def __init__(self):
        super().__init__(
            role=AgentRole.TRADER,
            capabilities=[
                AgentCapability.CRYPTO_DATA,
                AgentCapability.BACKTEST,
                AgentCapability.PAPER_TRADE,
                AgentCapability.LIVE_TRADE,
            ],
            provider_preference=ProviderPreference.AUTO,  # Quality chain: Claude -> GPT -> Ollama
        )
        TRADER_DIR.mkdir(parents=True, exist_ok=True)
        self._strategies: Dict[str, Strategy] = {}
        self._mode = TradingMode.RESEARCH
        self._load_strategies()

    def get_system_prompt(self) -> str:
        return """You are the Trader Agent in the Jarvis multi-agent system.

Your role is to research, develop, test, and execute crypto trading strategies.

YOU ARE THE REVENUE ENGINE. Your success directly funds Jarvis's operation.

PIPELINE STAGES:
1. RESEARCH: Gather market data, identify patterns
2. STRATEGY: Form hypothesis, define rules
3. BACKTEST: Test on historical data, compute metrics
4. PAPER TRADE: Simulated live testing
5. LIVE: Real execution (only with explicit approval)
6. LIQUIDATION SWEEP: Enter near smaller liquidation clusters, expecting cascades

MANDATORY METRICS (every strategy must track):
- Win Rate: % of profitable trades
- Profit Factor: Gross profit / Gross loss
- Max Drawdown: Largest peak-to-trough decline
- Sharpe Ratio: Risk-adjusted returns
- Expectancy: Average profit per trade

RISK RULES (non-negotiable):
1. NEVER risk more than 2% of portfolio per trade
2. ALWAYS have stop-loss defined
3. No live trading without successful paper trading
4. Log every decision with reasoning

OUTPUT FORMAT:
When analyzing, provide:
- SIGNAL: BUY/SELL/HOLD with confidence (0-100%)
- REASONING: Why this signal
- RISK: What could go wrong
- SIZE: Recommended position size
- STOPS: Entry, stop-loss, take-profit levels"""

    def _get_keywords(self) -> List[str]:
        return [
            "trade", "trading", "crypto", "bitcoin", "ethereum",
            "buy", "sell", "long", "short", "position",
            "strategy", "backtest", "paper", "live",
            "market", "price", "chart", "technical",
            "profit", "loss", "risk", "drawdown",
            "hyperliquid", "dex", "defi", "token",
        ]

    def execute(self, task: AgentTask) -> AgentResult:
        """Execute a trading task."""
        start_time = time.time()
        steps_taken = 0
        artifacts = {}

        try:
            # Determine trading mode from task
            mode = self._determine_mode(task)
            steps_taken += 1

            # Execute based on mode
            if mode == TradingMode.RESEARCH:
                output = self._do_research(task)
                steps_taken += 2
            elif mode == TradingMode.BACKTEST:
                output, results = self._do_backtest(task)
                artifacts["backtest"] = results
                steps_taken += 3
            elif mode == TradingMode.PAPER:
                output, trades = self._do_paper_trade(task)
                artifacts["paper_trades"] = trades
                steps_taken += 2
            elif mode == TradingMode.LIVE:
                output = self._do_live_check(task)  # Just validates, doesn't execute
                steps_taken += 1
            elif mode == TradingMode.STATUS:
                output = self._do_status(task)
                steps_taken += 1
            elif mode == TradingMode.LIQUIDATION:
                output = self._do_liquidation(task)
                steps_taken += 2
            elif mode == TradingMode.SOLANA_SCAN:
                output = self._do_solana_scan(task)
                steps_taken += 2
            else:
                output = self._do_analysis(task)
                steps_taken += 1

            return AgentResult(
                task_id=task.id,
                success=True,
                output=output,
                steps_taken=steps_taken,
                duration_ms=int((time.time() - start_time) * 1000),
                artifacts=artifacts,
                learnings=[f"Trading: {task.description[:50]}"],
            )

        except Exception as e:
            return AgentResult(
                task_id=task.id,
                success=False,
                output="",
                error=str(e)[:500],
                steps_taken=steps_taken,
                duration_ms=int((time.time() - start_time) * 1000),
            )

    def _determine_mode(self, task: AgentTask) -> TradingMode:
        """Determine what trading mode to use."""
        desc_lower = task.description.lower()

        if any(w in desc_lower for w in ["status", "pnl", "performance", "summary"]):
            return TradingMode.STATUS
        if any(w in desc_lower for w in ["liquidation", "liq", "sweep"]):
            return TradingMode.LIQUIDATION
        if any(w in desc_lower for w in ["solana scan", "meme scan", "scanner", "birdeye"]):
            return TradingMode.SOLANA_SCAN
        if any(w in desc_lower for w in ["research", "analyze", "study", "data"]):
            return TradingMode.RESEARCH
        elif any(w in desc_lower for w in ["backtest", "historical", "test strategy"]):
            return TradingMode.BACKTEST
        elif any(w in desc_lower for w in ["paper", "simulate", "practice"]):
            return TradingMode.PAPER
        elif any(w in desc_lower for w in ["live", "real", "execute trade"]):
            return TradingMode.LIVE
        else:
            return TradingMode.RESEARCH

    def _do_research(self, task: AgentTask) -> str:
        """Research crypto markets."""
        prompt = f"""Analyze the crypto market for this research task:

Task: {task.description}
Context: {json.dumps(task.context) if task.context else 'General market analysis'}

Provide:
1. MARKET OVERVIEW: Current state and sentiment
2. KEY OPPORTUNITIES: Potential trades with reasoning
3. RISKS: What could go wrong
4. DATA NEEDED: What additional data would help
5. STRATEGY IDEAS: Potential trading strategies to test

Be specific and actionable. Include confidence levels."""

        response, metadata = self.generate(prompt, priority="quality")
        return response

    def _do_backtest(self, task: AgentTask) -> Tuple[str, Dict]:
        """Backtest a trading strategy."""
        symbol, interval, strategy_cfg, lookback_days = self._parse_trading_request(task)

        trading_pipeline.ensure_hyperliquid_snapshot(symbol, interval, lookback_days)
        candles = trading_pipeline.load_candles_for_symbol(symbol, interval)

        result = trading_pipeline.run_backtest(
            candles=candles,
            symbol=symbol,
            interval=interval,
            strategy=strategy_cfg,
        )
        trading_pipeline.log_backtest_result(result)

        summary = trading_pipeline.format_backtest_summary(result)
        return summary, {
            "symbol": result.symbol,
            "interval": result.interval,
            "strategy": result.strategy,
            "params": result.params,
            "total_trades": result.total_trades,
            "win_rate": result.win_rate,
            "profit_factor": result.profit_factor,
            "max_drawdown": result.max_drawdown,
            "sharpe_ratio": result.sharpe_ratio,
            "expectancy": result.expectancy,
            "net_pnl": result.net_pnl,
            "roi": result.roi,
            "equity_start": result.equity_start,
            "equity_end": result.equity_end,
            "error": result.error,
        }

    def _do_paper_trade(self, task: AgentTask) -> Tuple[str, List[Dict]]:
        """Execute paper trading."""
        symbol, interval, strategy_cfg, lookback_days = self._parse_trading_request(task)

        trading_pipeline.ensure_hyperliquid_snapshot(symbol, interval, lookback_days)
        candles = trading_pipeline.load_candles_for_symbol(symbol, interval)

        result = trading_pipeline.paper_trade_cycle(
            candles=candles,
            symbol=symbol,
            interval=interval,
            strategy=strategy_cfg,
        )

        summary = trading_pipeline.format_paper_summary(result)
        trades: List[Dict[str, Any]] = []
        if result.get("opened_trade"):
            trades.append(result["opened_trade"])
        if result.get("closed_trade"):
            trades.append(result["closed_trade"])

        return summary, trades

    def _do_live_check(self, task: AgentTask) -> str:
        """Check if ready for live trading (doesn't execute)."""
        cfg = config.load_config()
        trading_cfg = cfg.get("trading", {})
        min_sharpe = float(trading_cfg.get("min_live_sharpe", 1.0))
        min_paper_days = int(trading_cfg.get("min_paper_days", 30))
        min_paper_trades = int(trading_cfg.get("min_paper_trades", 10))
        min_paper_roi = float(trading_cfg.get("min_paper_roi", 0.02))

        symbol, interval, strategy_cfg, _ = self._parse_trading_request(task)
        backtests = trading_pipeline.summarize_backtests(days=90, symbol=symbol)
        paper = trading_pipeline.summarize_paper_trades(days=min_paper_days, symbol=symbol)

        best_sharpe = 0.0
        best_roi = 0.0
        if backtests.get("best_sharpe"):
            try:
                best_sharpe = float(backtests["best_sharpe"].get("sharpe_ratio", 0.0))
                best_roi = float(backtests["best_sharpe"].get("roi", 0.0))
            except (TypeError, ValueError):
                best_sharpe = 0.0

        paper_days = 0.0
        if paper.get("first_trade_at") and paper.get("last_trade_at"):
            paper_days = (paper["last_trade_at"] - paper["first_trade_at"]) / 86400

        criteria = [
            ("Backtest Sharpe", best_sharpe >= min_sharpe, f"{best_sharpe:.2f} >= {min_sharpe:.2f}"),
            ("Paper days", paper_days >= min_paper_days, f"{paper_days:.1f} >= {min_paper_days}"),
            ("Paper trades", paper.get("total_trades", 0) >= min_paper_trades,
             f"{paper.get('total_trades', 0)} >= {min_paper_trades}"),
            ("Paper ROI", paper.get("roi", 0.0) >= min_paper_roi,
             f"{paper.get('roi', 0.0)*100:.2f}% >= {min_paper_roi*100:.2f}%"),
        ]

        lines = [
            "LIVE TRADING CHECK:",
            "",
            f"Symbol: {symbol} | Interval: {interval} | Strategy: {strategy_cfg.kind}",
            "",
            "REQUIREMENTS:",
        ]

        ready = True
        for label, ok, detail in criteria:
            status = "PASS" if ok else "FAIL"
            lines.append(f"- {label}: {status} ({detail})")
            if not ok:
                ready = False

        lines.extend([
            "",
            f"Status: {'APPROVED FOR LIVE' if ready else 'NOT APPROVED FOR LIVE'}",
            "",
            "Live trading requires explicit user approval and risk limits.",
        ])

        return "\n".join(lines)

    def _do_status(self, task: AgentTask) -> str:
        """Summarize recent trading performance."""
        symbol, interval, strategy_cfg, _ = self._parse_trading_request(task)
        backtests = trading_pipeline.summarize_backtests(days=90, symbol=symbol)
        paper = trading_pipeline.summarize_paper_trades(days=30, symbol=symbol)

        lines = [
            "TRADING STATUS:",
            "",
            f"Symbol: {symbol} | Interval: {interval} | Strategy: {strategy_cfg.kind}",
            "",
            "BACKTESTS (90d):",
        ]

        if backtests.get("count", 0) == 0:
            lines.append("- No backtests logged")
        else:
            best = backtests.get("best_sharpe", {})
            lines.append(
                f"- Count: {backtests.get('count')} | "
                f"Best Sharpe: {float(best.get('sharpe_ratio', 0.0)):.2f} | "
                f"ROI: {float(best.get('roi', 0.0))*100:.2f}%"
            )

        lines.append("")
        lines.append("PAPER (30d):")
        if paper.get("total_trades", 0) == 0:
            lines.append("- No closed paper trades")
        else:
            lines.append(
                f"- Trades: {paper.get('total_trades', 0)} | "
                f"Win rate: {paper.get('win_rate', 0.0)*100:.1f}% | "
                f"Net PnL: ${paper.get('net_pnl', 0.0):+.2f} | "
                f"ROI: {paper.get('roi', 0.0)*100:.2f}%"
            )

        return "\n".join(lines)

    def _do_liquidation(self, task: AgentTask) -> str:
        """Run liquidation sweep strategy and return signals."""
        cfg = config.load_config()
        symbols = cfg.get("liquidation_bot", {}).get("symbols", [])
        if task.context and task.context.get("symbols"):
            symbols = task.context.get("symbols")
        if task.context and task.context.get("symbol"):
            symbols = [task.context.get("symbol")]

        signals = liquidation_bot.run_cycle(symbols=symbols)
        if not signals:
            return "No liquidation signals triggered."

        lines = ["LIQUIDATION SWEEP SIGNALS:"]
        for signal in signals:
            lines.append(
                f"- {signal.symbol}: {signal.side.upper()} @ {signal.entry_price:.4f} "
                f"(liq ${signal.liquidation_usd:,.0f} >= ${signal.liquidation_threshold:,.0f}) "
                f"TP {signal.take_profit_price:.4f} SL {signal.stop_loss_price:.4f}"
            )
        return "\n".join(lines)

    def _do_solana_scan(self, task: AgentTask) -> str:
        """Run the Solana meme coin scanner and seed strategies."""
        cfg = config.load_config()
        scanner_cfg = cfg.get("solana_scanner", {})
        trending_limit = int(scanner_cfg.get("trending_limit", 200))
        new_token_hours = int(scanner_cfg.get("new_token_hours", 3))
        top_trader_limit = int(scanner_cfg.get("top_trader_limit", 100))

        result = solana_scanner.scan_all(
            trending_limit=trending_limit,
            new_token_hours=new_token_hours,
            top_trader_limit=top_trader_limit,
        )
        if result.get("error"):
            return f"Solana scan failed: {result['error']}"

        solana_scanner.seed_scanner_strategies()
        shortlist = solana_scanner.compile_strategy_shortlist()

        lines = [
            "Solana scanner complete:",
            f"- Trending tokens: {result.get('trending', 0)}",
            f"- New listings: {result.get('new_tokens', 0)}",
            f"- Top traders: {result.get('top_traders', 0)}",
            f"- Trending CSV: {result.get('trending_csv', '')}",
            f"- New tokens CSV: {result.get('new_tokens_csv', '')}",
            f"- Top traders CSV: {result.get('top_traders_csv', '')}",
            "Strategy shortlist:",
        ]
        for item in shortlist:
            lines.append(f"- {item['rank']}. {item['name']} ({item['id']})")
        return "\n".join(lines)

    def _do_analysis(self, task: AgentTask) -> str:
        """General trading analysis."""
        prompt = f"""Provide trading analysis for:

{task.description}

Include:
1. Market context
2. Technical levels
3. Risk assessment
4. Actionable recommendations"""

        response, _ = self.generate(prompt, priority="balanced")
        return response

    def _parse_trading_request(
        self,
        task: AgentTask,
    ) -> Tuple[str, str, trading_pipeline.StrategyConfig, int]:
        cfg = config.load_config()
        hcfg = cfg.get("hyperliquid", {})
        trading_cfg = cfg.get("trading", {})

        symbols = hcfg.get("symbols", ["BTC"])
        symbol = self._extract_symbol(task, symbols)
        interval = self._extract_interval(task, hcfg.get("interval", "1h"))
        lookback_days = int(hcfg.get("lookback_days", 30))

        strategy_cfg = self._build_strategy_config(task, trading_cfg)

        return symbol, interval, strategy_cfg, lookback_days

    def _extract_symbol(self, task: AgentTask, symbols: List[str]) -> str:
        if task.context:
            ctx_symbol = task.context.get("symbol") or task.context.get("pair")
            if ctx_symbol:
                raw = str(ctx_symbol).upper()
                if "/" in raw:
                    return raw.split("/")[0]
                for suffix in ("USDT", "USDC", "USD"):
                    if raw.endswith(suffix) and len(raw) > len(suffix):
                        return raw[:-len(suffix)]
                return raw

        desc = task.description.lower()
        name_map = {
            "bitcoin": "BTC",
            "ethereum": "ETH",
            "solana": "SOL",
        }
        for name, sym in name_map.items():
            if name in desc:
                return sym

        for sym in symbols:
            if sym.lower() in desc:
                return sym.upper()

        return symbols[0].upper() if symbols else "BTC"

    def _extract_interval(self, task: AgentTask, default_interval: str) -> str:
        if task.context and task.context.get("interval"):
            return str(task.context["interval"]).strip()

        match = re.search(r"(\d+\s*[mhdw])", task.description.lower())
        if match:
            return match.group(1).replace(" ", "")

        return default_interval

    def _build_strategy_config(
        self,
        task: AgentTask,
        trading_cfg: Dict[str, Any],
    ) -> trading_pipeline.StrategyConfig:
        desc = task.description.lower()
        strategy_kind = str(trading_cfg.get("strategy", "sma_cross"))

        if "rsi" in desc:
            strategy_kind = "rsi"
        elif "sma" in desc or "moving average" in desc or "ma " in desc:
            strategy_kind = "sma_cross"

        if task.context and task.context.get("strategy"):
            strategy_kind = str(task.context["strategy"])

        params: Dict[str, float] = {}
        if task.context:
            params.update(task.context.get("params", {}))

        if strategy_kind == "sma_cross":
            params.setdefault(
                "fast",
                self._extract_number(desc, r"fast\s*=?\s*(\d+)", trading_cfg.get("sma_fast", 5)),
            )
            params.setdefault(
                "slow",
                self._extract_number(desc, r"slow\s*=?\s*(\d+)", trading_cfg.get("sma_slow", 20)),
            )
        elif strategy_kind == "rsi":
            params.setdefault(
                "period",
                self._extract_number(desc, r"period\s*=?\s*(\d+)", trading_cfg.get("rsi_period", 14)),
            )
            params.setdefault(
                "lower",
                self._extract_number(desc, r"lower\s*=?\s*(\d+)", trading_cfg.get("rsi_lower", 30)),
            )
            params.setdefault(
                "upper",
                self._extract_number(desc, r"upper\s*=?\s*(\d+)", trading_cfg.get("rsi_upper", 70)),
            )

        return trading_pipeline.StrategyConfig(
            kind=strategy_kind,
            params=params,
            fee_bps=float(trading_cfg.get("fee_bps", 5.0)),
            slippage_bps=float(trading_cfg.get("slippage_bps", 2.0)),
            risk_per_trade=float(trading_cfg.get("risk_per_trade", 0.02)),
            stop_loss_pct=float(trading_cfg.get("stop_loss_pct", 0.03)),
            take_profit_pct=float(trading_cfg.get("take_profit_pct", 0.06)),
            max_position_pct=float(trading_cfg.get("max_position_pct", 0.25)),
            capital_usd=float(trading_cfg.get("paper_capital_usd", 1000.0)),
        )

    def _extract_number(self, text: str, pattern: str, default: float) -> float:
        match = re.search(pattern, text)
        if not match:
            return default
        try:
            return float(match.group(1))
        except ValueError:
            return default

    def _load_strategies(self) -> None:
        """Load saved strategies."""
        if STRATEGIES_FILE.exists():
            try:
                with open(STRATEGIES_FILE, "r") as f:
                    data = json.load(f)
                    for s in data.get("strategies", []):
                        self._strategies[s["id"]] = Strategy(**s)
            except Exception:
                pass

    def _save_strategies(self) -> None:
        """Save strategies to disk."""
        with open(STRATEGIES_FILE, "w") as f:
            json.dump({
                "strategies": [s.__dict__ for s in self._strategies.values()],
                "updated_at": time.time(),
            }, f, indent=2)

    def _log_backtest(self, results: Dict) -> None:
        """Log backtest results."""
        entry = {
            "timestamp": time.time(),
            **results,
        }
        with open(BACKTEST_RESULTS, "a") as f:
            f.write(json.dumps(entry) + "\n")

    def _log_paper_trade(self, trade: Dict) -> None:
        """Log paper trade."""
        entry = {
            "timestamp": time.time(),
            "mode": "paper",
            **trade,
        }
        with open(PAPER_TRADES_FILE, "a") as f:
            f.write(json.dumps(entry) + "\n")

    # Public methods for economic loop integration
    def get_pnl(self, days: int = 30) -> Dict[str, float]:
        """Get P&L for the economic loop."""
        summary = trading_pipeline.summarize_paper_trades(days=days)
        return {
            "paper_pnl": summary.get("net_pnl", 0.0),
            "live_pnl": 0.0,
            "total_trades": summary.get("total_trades", 0),
            "win_rate": summary.get("win_rate", 0.0),
        }

    def create_strategy(self, name: str, description: str, rules: Dict) -> Strategy:
        """Create a new trading strategy."""
        strategy = Strategy(
            id=str(uuid.uuid4())[:8],
            name=name,
            description=description,
            rules=rules,
        )
        self._strategies[strategy.id] = strategy
        self._save_strategies()
        return strategy
