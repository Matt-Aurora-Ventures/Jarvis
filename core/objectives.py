"""
Objective System for Jarvis Brain.

Manages a priority queue of objectives with:
- One active objective at a time
- Explicit success criteria
- Priority scoring (1-10)
- Lifecycle: pending -> active -> completed/failed
"""

import json
import time
import uuid
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional

from core import config


class ObjectiveStatus(str, Enum):
    PENDING = "pending"
    ACTIVE = "active"
    COMPLETED = "completed"
    FAILED = "failed"
    BLOCKED = "blocked"


class ObjectiveSource(str, Enum):
    USER = "user"           # User explicitly requested
    SYSTEM = "system"       # System-generated (missions, schedules)
    INFERRED = "inferred"   # Inferred from context/observation
    TRADER = "trader"       # Generated by Trader agent
    RESEARCHER = "researcher"  # Generated by Researcher agent


@dataclass
class SuccessCriterion:
    """A measurable success criterion for an objective."""
    description: str
    metric: str  # e.g., "file_created", "api_called", "value_changed"
    target: Any  # Expected value or state
    actual: Any = None
    met: bool = False


@dataclass
class Objective:
    """A single objective with explicit success criteria."""
    id: str
    description: str
    success_criteria: List[SuccessCriterion]
    priority: int  # 1-10, higher = more important
    source: ObjectiveSource
    status: ObjectiveStatus = ObjectiveStatus.PENDING
    created_at: float = field(default_factory=time.time)
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    deadline: Optional[float] = None
    parent_id: Optional[str] = None  # For sub-objectives
    context: Dict[str, Any] = field(default_factory=dict)
    outcome: str = ""
    failure_reason: str = ""
    attempts: int = 0
    max_attempts: int = 3

    def to_dict(self) -> Dict[str, Any]:
        d = asdict(self)
        d["status"] = self.status.value
        d["source"] = self.source.value
        d["success_criteria"] = [asdict(c) for c in self.success_criteria]
        return d

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "Objective":
        d = d.copy()
        d["status"] = ObjectiveStatus(d.get("status", "pending"))
        d["source"] = ObjectiveSource(d.get("source", "user"))
        d["success_criteria"] = [
            SuccessCriterion(**c) if isinstance(c, dict) else c
            for c in d.get("success_criteria", [])
        ]
        return cls(**d)

    def is_success(self) -> bool:
        """Check if all success criteria are met."""
        if not self.success_criteria:
            return False
        return all(c.met for c in self.success_criteria)

    def duration_seconds(self) -> Optional[float]:
        """Get duration if started."""
        if not self.started_at:
            return None
        end = self.completed_at or time.time()
        return end - self.started_at


ROOT = Path(__file__).resolve().parents[1]
OBJECTIVES_PATH = ROOT / "data" / "objectives"
ACTIVE_FILE = OBJECTIVES_PATH / "active.json"
QUEUE_FILE = OBJECTIVES_PATH / "queue.jsonl"
HISTORY_FILE = OBJECTIVES_PATH / "history.jsonl"


def _ensure_paths() -> None:
    OBJECTIVES_PATH.mkdir(parents=True, exist_ok=True)


def _read_jsonl(path: Path) -> List[Dict[str, Any]]:
    if not path.exists():
        return []
    items = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    items.append(json.loads(line))
                except json.JSONDecodeError:
                    continue
    return items


def _write_jsonl(path: Path, items: List[Dict[str, Any]]) -> None:
    _ensure_paths()
    with open(path, "w", encoding="utf-8") as f:
        for item in items:
            f.write(json.dumps(item, ensure_ascii=False) + "\n")


def _append_jsonl(path: Path, item: Dict[str, Any]) -> None:
    _ensure_paths()
    with open(path, "a", encoding="utf-8") as f:
        f.write(json.dumps(item, ensure_ascii=False) + "\n")


class ObjectiveManager:
    """
    Manages objectives with a single active objective constraint.

    Key invariants:
    - At most ONE objective can be active at any time
    - Objectives are processed by priority (highest first)
    - Every objective has explicit success criteria
    - Completed/failed objectives are moved to history
    """

    def __init__(self):
        _ensure_paths()
        self._active: Optional[Objective] = None
        self._load_active()

    def _load_active(self) -> None:
        """Load the currently active objective."""
        if ACTIVE_FILE.exists():
            try:
                with open(ACTIVE_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    if data:
                        self._active = Objective.from_dict(data)
            except (json.JSONDecodeError, Exception):
                self._active = None

    def _save_active(self) -> None:
        """Persist the active objective."""
        _ensure_paths()
        with open(ACTIVE_FILE, "w", encoding="utf-8") as f:
            if self._active:
                json.dump(self._active.to_dict(), f, indent=2)
            else:
                json.dump(None, f)

    def get_active(self) -> Optional[Objective]:
        """Get the currently active objective, or None."""
        return self._active

    def create_objective(
        self,
        description: str,
        success_criteria: List[Dict[str, Any]],
        priority: int = 5,
        source: ObjectiveSource = ObjectiveSource.USER,
        deadline: Optional[float] = None,
        context: Optional[Dict[str, Any]] = None,
        parent_id: Optional[str] = None,
    ) -> Objective:
        """Create a new objective and add to queue."""
        criteria = [
            SuccessCriterion(
                description=c.get("description", ""),
                metric=c.get("metric", "unknown"),
                target=c.get("target"),
            )
            for c in success_criteria
        ]

        obj = Objective(
            id=str(uuid.uuid4())[:8],
            description=description,
            success_criteria=criteria,
            priority=max(1, min(10, priority)),
            source=source,
            deadline=deadline,
            context=context or {},
            parent_id=parent_id,
        )

        # Add to queue
        _append_jsonl(QUEUE_FILE, obj.to_dict())
        return obj

    def activate_next(self) -> Optional[Objective]:
        """
        Activate the highest priority pending objective.

        Returns None if there's already an active objective
        or the queue is empty.
        """
        if self._active:
            return None  # Already have an active objective

        # Read queue, sort by priority (desc), deadline (asc)
        queue = _read_jsonl(QUEUE_FILE)
        if not queue:
            return None

        # Sort: higher priority first, earlier deadline first
        def sort_key(item):
            priority = -item.get("priority", 5)
            deadline = item.get("deadline") or float("inf")
            return (priority, deadline)

        queue.sort(key=sort_key)

        # Take the first one
        next_obj_dict = queue.pop(0)
        next_obj = Objective.from_dict(next_obj_dict)
        next_obj.status = ObjectiveStatus.ACTIVE
        next_obj.started_at = time.time()
        next_obj.attempts += 1

        # Save remaining queue
        _write_jsonl(QUEUE_FILE, queue)

        # Set as active
        self._active = next_obj
        self._save_active()

        return next_obj

    def complete(
        self,
        obj_id: str,
        outcome: str,
        criteria_results: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """
        Mark objective as completed with outcome.

        criteria_results: Maps criterion description to actual value
        """
        if not self._active or self._active.id != obj_id:
            return False

        self._active.status = ObjectiveStatus.COMPLETED
        self._active.completed_at = time.time()
        self._active.outcome = outcome

        # Update success criteria actuals
        if criteria_results:
            for criterion in self._active.success_criteria:
                if criterion.description in criteria_results:
                    criterion.actual = criteria_results[criterion.description]
                    criterion.met = criterion.actual == criterion.target

        # Move to history
        _append_jsonl(HISTORY_FILE, self._active.to_dict())

        # Clear active
        self._active = None
        self._save_active()

        return True

    def fail(self, obj_id: str, reason: str, requeue: bool = False) -> bool:
        """
        Mark objective as failed.

        If requeue=True and attempts < max_attempts, re-add to queue.
        """
        if not self._active or self._active.id != obj_id:
            return False

        self._active.failure_reason = reason
        self._active.completed_at = time.time()

        if requeue and self._active.attempts < self._active.max_attempts:
            # Re-queue with lower priority
            self._active.status = ObjectiveStatus.PENDING
            self._active.priority = max(1, self._active.priority - 1)
            self._active.started_at = None
            self._active.completed_at = None
            _append_jsonl(QUEUE_FILE, self._active.to_dict())
        else:
            self._active.status = ObjectiveStatus.FAILED
            _append_jsonl(HISTORY_FILE, self._active.to_dict())

        # Clear active
        self._active = None
        self._save_active()

        return True

    def block(self, obj_id: str, reason: str) -> bool:
        """Mark objective as blocked (waiting for external input)."""
        if not self._active or self._active.id != obj_id:
            return False

        self._active.status = ObjectiveStatus.BLOCKED
        self._active.context["blocked_reason"] = reason
        self._active.context["blocked_at"] = time.time()
        self._save_active()

        return True

    def unblock(self, obj_id: str) -> bool:
        """Resume a blocked objective."""
        if not self._active or self._active.id != obj_id:
            return False

        if self._active.status != ObjectiveStatus.BLOCKED:
            return False

        self._active.status = ObjectiveStatus.ACTIVE
        self._active.context.pop("blocked_reason", None)
        self._active.context.pop("blocked_at", None)
        self._save_active()

        return True

    def get_queue(self, limit: int = 10) -> List[Objective]:
        """Get pending objectives sorted by priority."""
        queue = _read_jsonl(QUEUE_FILE)
        queue.sort(key=lambda x: (-x.get("priority", 5), x.get("deadline") or float("inf")))
        return [Objective.from_dict(d) for d in queue[:limit]]

    def get_history(self, limit: int = 20) -> List[Objective]:
        """Get recent completed/failed objectives."""
        history = _read_jsonl(HISTORY_FILE)
        return [Objective.from_dict(d) for d in history[-limit:]]

    def clear_queue(self) -> int:
        """Clear all pending objectives. Returns count cleared."""
        queue = _read_jsonl(QUEUE_FILE)
        count = len(queue)
        _write_jsonl(QUEUE_FILE, [])
        return count

    def status_summary(self) -> Dict[str, Any]:
        """Get a summary of objective system status."""
        queue = _read_jsonl(QUEUE_FILE)
        history = _read_jsonl(HISTORY_FILE)

        completed = sum(1 for h in history if h.get("status") == "completed")
        failed = sum(1 for h in history if h.get("status") == "failed")

        return {
            "active": self._active.to_dict() if self._active else None,
            "queue_size": len(queue),
            "history_size": len(history),
            "completed_count": completed,
            "failed_count": failed,
            "success_rate": completed / max(1, completed + failed),
        }


# Global instance for convenience
_manager: Optional[ObjectiveManager] = None


def get_manager() -> ObjectiveManager:
    """Get the global ObjectiveManager instance."""
    global _manager
    if _manager is None:
        _manager = ObjectiveManager()
    return _manager


# Convenience functions
def create_objective(
    description: str,
    success_criteria: List[Dict[str, Any]],
    **kwargs,
) -> Objective:
    """Create a new objective."""
    return get_manager().create_objective(description, success_criteria, **kwargs)


def get_active() -> Optional[Objective]:
    """Get the currently active objective."""
    return get_manager().get_active()


def activate_next() -> Optional[Objective]:
    """Activate the next objective from queue."""
    return get_manager().activate_next()


def complete_objective(obj_id: str, outcome: str, **kwargs) -> bool:
    """Complete an objective."""
    return get_manager().complete(obj_id, outcome, **kwargs)


def fail_objective(obj_id: str, reason: str, requeue: bool = False) -> bool:
    """Fail an objective."""
    return get_manager().fail(obj_id, reason, requeue=requeue)
