"""
RSI Strategy with Divergence Detection

Implements RSI-based trading signals including:
- RSI oversold/overbought conditions
- Bullish divergence (price lower low, RSI higher low)
- Bearish divergence (price higher high, RSI lower high)

Signals:
- RSI_OVERSOLD: RSI < 30, potential long opportunity
- RSI_OVERBOUGHT: RSI > 70, potential short opportunity
- RSI_BULLISH_DIVERGENCE: Bullish divergence detected
- RSI_BEARISH_DIVERGENCE: Bearish divergence detected
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple
import statistics

logger = logging.getLogger(__name__)


@dataclass
class RSISignal:
    """
    Signal generated by RSI analysis.
    """
    signal_type: str  # RSI_OVERSOLD, RSI_OVERBOUGHT, RSI_BULLISH_DIVERGENCE, etc.
    confidence: float
    direction: str  # long, short, neutral
    rsi_value: float
    has_divergence: bool
    divergence_type: Optional[str]  # bullish, bearish, None
    price_swing_low: Optional[float]
    price_swing_high: Optional[float]
    rsi_swing_low: Optional[float]
    rsi_swing_high: Optional[float]
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'direction': self.direction,
            'rsi_value': self.rsi_value,
            'has_divergence': self.has_divergence,
            'divergence_type': self.divergence_type,
            'price_swing_low': self.price_swing_low,
            'price_swing_high': self.price_swing_high,
            'rsi_swing_low': self.rsi_swing_low,
            'rsi_swing_high': self.rsi_swing_high,
            'timestamp': self.timestamp.isoformat(),
        }


class RSIAnalyzer:
    """
    RSI analyzer with divergence detection.

    Configuration:
        period: RSI calculation period (default 14)
        oversold_threshold: Level below which RSI is oversold (default 30)
        overbought_threshold: Level above which RSI is overbought (default 70)
        divergence_lookback: Number of periods to look back for divergences (default 10)
    """

    def __init__(
        self,
        period: int = 14,
        oversold_threshold: float = 30,
        overbought_threshold: float = 70,
        divergence_lookback: int = 10,
    ):
        self.period = period
        self.oversold_threshold = oversold_threshold
        self.overbought_threshold = overbought_threshold
        self.divergence_lookback = divergence_lookback

        # Price history
        self._prices: List[float] = []

        # RSI history for divergence detection
        self._rsi_history: List[float] = []

        # Gain/loss tracking for Wilder's smoothed RSI
        self._avg_gain: Optional[float] = None
        self._avg_loss: Optional[float] = None

        logger.info(
            f"RSIAnalyzer initialized: period={period}, "
            f"oversold={oversold_threshold}, overbought={overbought_threshold}"
        )

    def add_price(self, price: float) -> None:
        """Add a new price observation."""
        self._prices.append(price)

        # Keep history bounded
        max_history = max(self.period * 3, self.divergence_lookback * 2)
        if len(self._prices) > max_history:
            self._prices = self._prices[-max_history:]

        # Calculate RSI if we have enough data
        rsi = self._calculate_rsi()
        if rsi is not None:
            self._rsi_history.append(rsi)
            if len(self._rsi_history) > max_history:
                self._rsi_history = self._rsi_history[-max_history:]

    def add_prices(self, prices: List[float]) -> None:
        """Add multiple price observations."""
        for price in prices:
            self.add_price(price)

    def _calculate_rsi(self) -> Optional[float]:
        """
        Calculate RSI using Wilder's smoothed moving average method.
        """
        if len(self._prices) < self.period + 1:
            return None

        # Calculate price changes
        changes = [
            self._prices[i] - self._prices[i - 1]
            for i in range(1, len(self._prices))
        ]

        # Get recent changes
        recent_changes = changes[-self.period:]

        if self._avg_gain is None or self._avg_loss is None:
            # First calculation: simple average
            gains = [max(c, 0) for c in recent_changes]
            losses = [abs(min(c, 0)) for c in recent_changes]
            self._avg_gain = sum(gains) / self.period
            self._avg_loss = sum(losses) / self.period
        else:
            # Wilder's smoothed average
            current_change = changes[-1]
            current_gain = max(current_change, 0)
            current_loss = abs(min(current_change, 0))

            self._avg_gain = (self._avg_gain * (self.period - 1) + current_gain) / self.period
            self._avg_loss = (self._avg_loss * (self.period - 1) + current_loss) / self.period

        if self._avg_loss == 0:
            return 100.0

        rs = self._avg_gain / self._avg_loss
        rsi = 100 - (100 / (1 + rs))

        return rsi

    def get_rsi(self) -> Optional[float]:
        """Get the current RSI value."""
        if not self._rsi_history:
            return self._calculate_rsi()
        return self._rsi_history[-1] if self._rsi_history else None

    def _find_swing_lows(self, data: List[float], lookback: int) -> List[Tuple[int, float]]:
        """Find swing lows in the data."""
        swings = []
        if len(data) < 3:
            return swings

        for i in range(1, len(data) - 1):
            # Simple swing low: lower than neighbors
            if data[i] < data[i - 1] and data[i] < data[i + 1]:
                swings.append((i, data[i]))

        # Return recent swings within lookback
        return [(i, v) for i, v in swings if i >= len(data) - lookback]

    def _find_swing_highs(self, data: List[float], lookback: int) -> List[Tuple[int, float]]:
        """Find swing highs in the data."""
        swings = []
        if len(data) < 3:
            return swings

        for i in range(1, len(data) - 1):
            # Simple swing high: higher than neighbors
            if data[i] > data[i - 1] and data[i] > data[i + 1]:
                swings.append((i, data[i]))

        # Return recent swings within lookback
        return [(i, v) for i, v in swings if i >= len(data) - lookback]

    def _detect_bullish_divergence(self) -> Tuple[bool, Optional[float], Optional[float]]:
        """
        Detect bullish divergence: price makes lower low, RSI makes higher low.
        """
        if len(self._prices) < self.divergence_lookback or len(self._rsi_history) < self.divergence_lookback:
            return False, None, None

        price_swings = self._find_swing_lows(self._prices, self.divergence_lookback)
        rsi_swings = self._find_swing_lows(self._rsi_history, self.divergence_lookback)

        if len(price_swings) < 2 or len(rsi_swings) < 2:
            return False, None, None

        # Get the two most recent swing lows
        price_lows = sorted(price_swings, key=lambda x: x[0])[-2:]
        rsi_lows = sorted(rsi_swings, key=lambda x: x[0])[-2:]

        # Bullish divergence: price lower low + RSI higher low
        if price_lows[1][1] < price_lows[0][1] and rsi_lows[1][1] > rsi_lows[0][1]:
            return True, price_lows[1][1], rsi_lows[1][1]

        return False, None, None

    def _detect_bearish_divergence(self) -> Tuple[bool, Optional[float], Optional[float]]:
        """
        Detect bearish divergence: price makes higher high, RSI makes lower high.
        """
        if len(self._prices) < self.divergence_lookback or len(self._rsi_history) < self.divergence_lookback:
            return False, None, None

        price_swings = self._find_swing_highs(self._prices, self.divergence_lookback)
        rsi_swings = self._find_swing_highs(self._rsi_history, self.divergence_lookback)

        if len(price_swings) < 2 or len(rsi_swings) < 2:
            return False, None, None

        # Get the two most recent swing highs
        price_highs = sorted(price_swings, key=lambda x: x[0])[-2:]
        rsi_highs = sorted(rsi_swings, key=lambda x: x[0])[-2:]

        # Bearish divergence: price higher high + RSI lower high
        if price_highs[1][1] > price_highs[0][1] and rsi_highs[1][1] < rsi_highs[0][1]:
            return True, price_highs[1][1], rsi_highs[1][1]

        return False, None, None

    def analyze(self) -> RSISignal:
        """
        Analyze current RSI and detect signals.

        Returns:
            RSISignal with signal type and details
        """
        rsi = self.get_rsi()

        if rsi is None:
            return RSISignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                direction="neutral",
                rsi_value=0.0,
                has_divergence=False,
                divergence_type=None,
                price_swing_low=None,
                price_swing_high=None,
                rsi_swing_low=None,
                rsi_swing_high=None,
            )

        # Check for divergences first (higher priority)
        bullish_div, price_low, rsi_low = self._detect_bullish_divergence()
        bearish_div, price_high, rsi_high = self._detect_bearish_divergence()

        if bullish_div:
            logger.info(f"RSI BULLISH DIVERGENCE detected: RSI={rsi:.1f}")
            return RSISignal(
                signal_type="RSI_BULLISH_DIVERGENCE",
                confidence=0.75,
                direction="long",
                rsi_value=rsi,
                has_divergence=True,
                divergence_type="bullish",
                price_swing_low=price_low,
                price_swing_high=None,
                rsi_swing_low=rsi_low,
                rsi_swing_high=None,
            )

        if bearish_div:
            logger.info(f"RSI BEARISH DIVERGENCE detected: RSI={rsi:.1f}")
            return RSISignal(
                signal_type="RSI_BEARISH_DIVERGENCE",
                confidence=0.75,
                direction="short",
                rsi_value=rsi,
                has_divergence=True,
                divergence_type="bearish",
                price_swing_low=None,
                price_swing_high=price_high,
                rsi_swing_low=None,
                rsi_swing_high=rsi_high,
            )

        # Check oversold/overbought
        if rsi < self.oversold_threshold:
            logger.info(f"RSI OVERSOLD: {rsi:.1f}")
            return RSISignal(
                signal_type="RSI_OVERSOLD",
                confidence=0.6,
                direction="long",
                rsi_value=rsi,
                has_divergence=False,
                divergence_type=None,
                price_swing_low=None,
                price_swing_high=None,
                rsi_swing_low=None,
                rsi_swing_high=None,
            )

        if rsi > self.overbought_threshold:
            logger.info(f"RSI OVERBOUGHT: {rsi:.1f}")
            return RSISignal(
                signal_type="RSI_OVERBOUGHT",
                confidence=0.6,
                direction="short",
                rsi_value=rsi,
                has_divergence=False,
                divergence_type=None,
                price_swing_low=None,
                price_swing_high=None,
                rsi_swing_low=None,
                rsi_swing_high=None,
            )

        # Neutral zone
        return RSISignal(
            signal_type="NO_SIGNAL",
            confidence=0.0,
            direction="neutral",
            rsi_value=rsi,
            has_divergence=False,
            divergence_type=None,
            price_swing_low=None,
            price_swing_high=None,
            rsi_swing_low=None,
            rsi_swing_high=None,
        )

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        rsi = self.get_rsi()
        return {
            'current_rsi': rsi,
            'prices_tracked': len(self._prices),
            'rsi_history_size': len(self._rsi_history),
            'period': self.period,
            'oversold_threshold': self.oversold_threshold,
            'overbought_threshold': self.overbought_threshold,
        }
