"""
Mean Reversion Strategy with Bollinger Bands

Implements mean reversion trading based on Bollinger Bands:
- Enter when price moves to band extremes
- Exit when price returns to mean (middle band)

Signals:
- MEAN_REVERSION_BUY: Price below lower band (oversold)
- MEAN_REVERSION_SELL: Price above upper band (overbought)
- MEAN_REVERSION_EXIT: Price has reverted to mean
"""

import logging
import statistics
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple

logger = logging.getLogger(__name__)


@dataclass
class MeanReversionSignal:
    """
    Signal generated by mean reversion analysis.
    """
    signal_type: str  # MEAN_REVERSION_BUY, MEAN_REVERSION_SELL, etc.
    confidence: float
    direction: str  # long, short, neutral
    should_exit: bool
    current_price: float
    upper_band: float
    middle_band: float
    lower_band: float
    band_width: float
    percent_b: float  # Position within bands (0=lower, 1=upper)
    above_upper_band: bool
    below_lower_band: bool
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'direction': self.direction,
            'should_exit': self.should_exit,
            'current_price': self.current_price,
            'upper_band': self.upper_band,
            'middle_band': self.middle_band,
            'lower_band': self.lower_band,
            'band_width': self.band_width,
            'percent_b': self.percent_b,
            'above_upper_band': self.above_upper_band,
            'below_lower_band': self.below_lower_band,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class MeanReversionPosition:
    """Track position for exit signals."""
    symbol: str
    side: str  # long, short
    entry_band_position: str  # below_lower, above_upper
    entry_price: float
    opened_at: datetime = field(default_factory=datetime.utcnow)


class MeanReversionAnalyzer:
    """
    Mean reversion analyzer using Bollinger Bands.

    Configuration:
        bb_period: Bollinger Bands period (default 20)
        bb_std_dev: Number of standard deviations (default 2.0)
        exit_threshold: How close to middle band to trigger exit (default 0.1)
    """

    def __init__(
        self,
        bb_period: int = 20,
        bb_std_dev: float = 2.0,
        exit_threshold: float = 0.1,
    ):
        self.bb_period = bb_period
        self.bb_std_dev = bb_std_dev
        self.exit_threshold = exit_threshold

        # Price history
        self._prices: List[float] = []

        # Position tracking
        self._positions: Dict[str, MeanReversionPosition] = {}

        logger.info(
            f"MeanReversionAnalyzer initialized: period={bb_period}, "
            f"std_dev={bb_std_dev}, exit_threshold={exit_threshold}"
        )

    def add_price(self, price: float) -> None:
        """Add a new price observation."""
        self._prices.append(price)

        # Keep history bounded
        max_history = self.bb_period * 3
        if len(self._prices) > max_history:
            self._prices = self._prices[-max_history:]

    def add_prices(self, prices: List[float]) -> None:
        """Add multiple price observations."""
        for price in prices:
            self.add_price(price)

    def get_bollinger_bands(self) -> Tuple[Optional[float], Optional[float], Optional[float]]:
        """
        Calculate Bollinger Bands.

        Returns:
            Tuple of (upper_band, middle_band, lower_band)
        """
        if len(self._prices) < self.bb_period:
            return None, None, None

        recent_prices = self._prices[-self.bb_period:]

        # Middle band (SMA)
        middle = statistics.mean(recent_prices)

        # Standard deviation
        std_dev = statistics.stdev(recent_prices)

        # Upper and lower bands
        upper = middle + (self.bb_std_dev * std_dev)
        lower = middle - (self.bb_std_dev * std_dev)

        return upper, middle, lower

    def get_band_width(self) -> Optional[float]:
        """
        Calculate Bollinger Band Width.
        Band Width = (Upper - Lower) / Middle

        Returns:
            Band width as a ratio
        """
        upper, middle, lower = self.get_bollinger_bands()
        if upper is None or middle is None or lower is None or middle == 0:
            return None
        return (upper - lower) / middle

    def _calculate_percent_b(
        self,
        price: float,
        upper: float,
        middle: float,
        lower: float
    ) -> float:
        """
        Calculate %B indicator.
        %B = (Price - Lower) / (Upper - Lower)
        0 = at lower band, 0.5 = at middle, 1 = at upper band
        """
        band_range = upper - lower
        if band_range == 0:
            return 0.5
        return (price - lower) / band_range

    def set_position(
        self,
        symbol: str,
        side: str,
        entry_band_position: str,
    ) -> None:
        """
        Set a position for exit tracking.

        Args:
            symbol: Trading symbol
            side: 'long' or 'short'
            entry_band_position: 'below_lower' or 'above_upper'
        """
        current_price = self._prices[-1] if self._prices else 0.0
        self._positions[symbol] = MeanReversionPosition(
            symbol=symbol,
            side=side,
            entry_band_position=entry_band_position,
            entry_price=current_price,
        )
        logger.info(
            f"Mean reversion position set: {symbol} {side} "
            f"entry_position={entry_band_position}"
        )

    def close_position(self, symbol: str) -> None:
        """Close and stop tracking a position."""
        if symbol in self._positions:
            del self._positions[symbol]
            logger.info(f"Mean reversion position closed: {symbol}")

    def analyze(self) -> MeanReversionSignal:
        """
        Analyze current price relative to Bollinger Bands.

        Returns:
            MeanReversionSignal with entry recommendation
        """
        upper, middle, lower = self.get_bollinger_bands()

        if upper is None or middle is None or lower is None:
            return MeanReversionSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                direction="neutral",
                should_exit=False,
                current_price=self._prices[-1] if self._prices else 0.0,
                upper_band=0.0,
                middle_band=0.0,
                lower_band=0.0,
                band_width=0.0,
                percent_b=0.5,
                above_upper_band=False,
                below_lower_band=False,
            )

        current_price = self._prices[-1]
        band_width = self.get_band_width() or 0.0
        percent_b = self._calculate_percent_b(current_price, upper, middle, lower)

        above_upper = current_price > upper
        below_lower = current_price < lower

        # Determine signal type
        if below_lower:
            signal_type = "MEAN_REVERSION_BUY"
            direction = "long"
            confidence = 0.65
            logger.info(
                f"MEAN REVERSION BUY: price={current_price:.2f} < lower={lower:.2f}"
            )
        elif above_upper:
            signal_type = "MEAN_REVERSION_SELL"
            direction = "short"
            confidence = 0.65
            logger.info(
                f"MEAN REVERSION SELL: price={current_price:.2f} > upper={upper:.2f}"
            )
        else:
            signal_type = "NO_SIGNAL"
            direction = "neutral"
            confidence = 0.0

        return MeanReversionSignal(
            signal_type=signal_type,
            confidence=confidence,
            direction=direction,
            should_exit=False,
            current_price=current_price,
            upper_band=upper,
            middle_band=middle,
            lower_band=lower,
            band_width=band_width,
            percent_b=percent_b,
            above_upper_band=above_upper,
            below_lower_band=below_lower,
        )

    def analyze_exit(self, symbol: str) -> MeanReversionSignal:
        """
        Analyze whether an existing position should exit (return to mean).

        Args:
            symbol: Trading symbol with active position

        Returns:
            MeanReversionSignal with exit recommendation
        """
        upper, middle, lower = self.get_bollinger_bands()

        if upper is None or middle is None or lower is None:
            return MeanReversionSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                direction="neutral",
                should_exit=False,
                current_price=self._prices[-1] if self._prices else 0.0,
                upper_band=0.0,
                middle_band=0.0,
                lower_band=0.0,
                band_width=0.0,
                percent_b=0.5,
                above_upper_band=False,
                below_lower_band=False,
            )

        current_price = self._prices[-1]
        band_width = self.get_band_width() or 0.0
        percent_b = self._calculate_percent_b(current_price, upper, middle, lower)

        above_upper = current_price > upper
        below_lower = current_price < lower

        # Check if price has returned to mean
        distance_from_middle = abs(current_price - middle) / middle
        at_mean = distance_from_middle <= self.exit_threshold

        if symbol in self._positions and at_mean:
            pos = self._positions[symbol]
            logger.info(
                f"MEAN REVERSION EXIT: {symbol} returned to mean, "
                f"price={current_price:.2f}, middle={middle:.2f}"
            )
            return MeanReversionSignal(
                signal_type="MEAN_REVERSION_EXIT",
                confidence=0.8,
                direction="neutral",
                should_exit=True,
                current_price=current_price,
                upper_band=upper,
                middle_band=middle,
                lower_band=lower,
                band_width=band_width,
                percent_b=percent_b,
                above_upper_band=above_upper,
                below_lower_band=below_lower,
            )

        return MeanReversionSignal(
            signal_type="NO_SIGNAL",
            confidence=0.0,
            direction="neutral",
            should_exit=False,
            current_price=current_price,
            upper_band=upper,
            middle_band=middle,
            lower_band=lower,
            band_width=band_width,
            percent_b=percent_b,
            above_upper_band=above_upper,
            below_lower_band=below_lower,
        )

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        upper, middle, lower = self.get_bollinger_bands()
        band_width = self.get_band_width()

        return {
            'upper_band': upper,
            'middle_band': middle,
            'lower_band': lower,
            'band_width': band_width,
            'prices_tracked': len(self._prices),
            'positions_tracked': len(self._positions),
            'bb_period': self.bb_period,
            'bb_std_dev': self.bb_std_dev,
        }
