"""
Volume Profile Strategy

Analyzes volume distribution across price levels to identify:
- Point of Control (POC): Price level with highest volume
- Value Area: Price range containing 70% of volume
- High Volume Nodes (HVN): Support/resistance levels
- Low Volume Nodes (LVN): Potential breakout zones

Signals:
- VOLUME_SUPPORT: High volume node below current price (support)
- VOLUME_RESISTANCE: High volume node above current price (resistance)
- VOLUME_BREAKOUT_ZONE: Price in low volume area (easy movement)
- VOLUME_POC_BOUNCE: Price near Point of Control (magnet level)
- NO_SIGNAL: Insufficient data or no clear signal
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple

logger = logging.getLogger(__name__)


@dataclass
class VolumeProfileSignal:
    """
    Signal generated by volume profile analysis.
    """
    signal_type: str  # VOLUME_SUPPORT, VOLUME_RESISTANCE, VOLUME_BREAKOUT_ZONE, etc.
    confidence: float
    direction: str  # long, short, neutral

    # Key levels
    support_level: Optional[float]
    resistance_level: Optional[float]
    point_of_control: Optional[float]
    value_area_high: Optional[float]
    value_area_low: Optional[float]

    # Confidence in levels
    support_confidence: float
    resistance_confidence: float
    poc_significance: float

    # Current state
    current_price: float
    near_poc: bool
    in_value_area: bool
    in_low_volume_zone: bool

    # Metadata
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'direction': self.direction,
            'support_level': self.support_level,
            'resistance_level': self.resistance_level,
            'point_of_control': self.point_of_control,
            'value_area_high': self.value_area_high,
            'value_area_low': self.value_area_low,
            'support_confidence': self.support_confidence,
            'resistance_confidence': self.resistance_confidence,
            'poc_significance': self.poc_significance,
            'current_price': self.current_price,
            'near_poc': self.near_poc,
            'in_value_area': self.in_value_area,
            'in_low_volume_zone': self.in_low_volume_zone,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class VolumeBin:
    """A single price level bin with volume data."""
    price_low: float
    price_high: float
    price_mid: float
    volume: float


class VolumeProfileAnalyzer:
    """
    Volume profile analyzer that builds volume distribution and identifies key levels.

    Configuration:
        num_bins: Number of price bins for volume distribution (default 20)
        lookback_period: Number of price/volume observations to consider (default 100)
        value_area_pct: Percentage of volume for value area (default 0.70 = 70%)
    """

    def __init__(
        self,
        num_bins: int = 20,
        lookback_period: int = 100,
        value_area_pct: float = 0.70,
    ):
        self.num_bins = num_bins
        self.lookback_period = lookback_period
        self.value_area_pct = value_area_pct

        # Price and volume history
        self._prices: List[float] = []
        self._volumes: List[float] = []

        logger.info(
            f"VolumeProfileAnalyzer initialized: bins={num_bins}, "
            f"lookback={lookback_period}, value_area={value_area_pct:.0%}"
        )

    def add_data(self, price: float, volume: float) -> None:
        """
        Add a new price/volume observation.

        Args:
            price: Price at this level
            volume: Volume traded at this level
        """
        self._prices.append(price)
        self._volumes.append(volume)

        # Keep history bounded
        max_history = self.lookback_period * 2
        if len(self._prices) > max_history:
            self._prices = self._prices[-max_history:]
            self._volumes = self._volumes[-max_history:]

    def _build_volume_profile(self) -> List[VolumeBin]:
        """
        Build volume profile by distributing volume into price bins.

        Returns:
            List of VolumeBin objects sorted by price
        """
        if len(self._prices) < 10:
            return []

        # Use lookback period of data
        prices = self._prices[-self.lookback_period:] if len(self._prices) >= self.lookback_period else self._prices
        volumes = self._volumes[-self.lookback_period:] if len(self._volumes) >= self.lookback_period else self._volumes

        price_min = min(prices)
        price_max = max(prices)
        price_range = price_max - price_min

        if price_range == 0:
            return []

        bin_size = price_range / self.num_bins

        # Initialize bins
        bins = []
        for i in range(self.num_bins):
            price_low = price_min + i * bin_size
            price_high = price_min + (i + 1) * bin_size
            price_mid = (price_low + price_high) / 2
            bins.append(VolumeBin(
                price_low=price_low,
                price_high=price_high,
                price_mid=price_mid,
                volume=0.0
            ))

        # Distribute volume into bins
        for price, volume in zip(prices, volumes):
            bin_idx = int((price - price_min) / bin_size)
            bin_idx = min(bin_idx, self.num_bins - 1)  # Handle edge case
            bins[bin_idx].volume += volume

        return bins

    def get_point_of_control(self) -> Optional[float]:
        """
        Get Point of Control (POC) - price level with highest volume.

        Returns:
            POC price level or None if insufficient data
        """
        bins = self._build_volume_profile()
        if not bins:
            return None

        # Find bin with highest volume
        max_bin = max(bins, key=lambda b: b.volume)
        return max_bin.price_mid

    def get_value_area(self) -> Tuple[Optional[float], Optional[float]]:
        """
        Get Value Area High and Low (contains 70% of volume).

        Returns:
            Tuple of (VAH, VAL) or (None, None) if insufficient data
        """
        bins = self._build_volume_profile()
        if not bins:
            return None, None

        total_volume = sum(b.volume for b in bins)
        if total_volume == 0:
            return None, None

        target_volume = total_volume * self.value_area_pct

        # Start from POC and expand outward
        poc_idx = max(range(len(bins)), key=lambda i: bins[i].volume)

        included = [poc_idx]
        current_volume = bins[poc_idx].volume
        low_idx = poc_idx
        high_idx = poc_idx

        while current_volume < target_volume:
            # Check volume in adjacent bins
            next_low = low_idx - 1 if low_idx > 0 else None
            next_high = high_idx + 1 if high_idx < len(bins) - 1 else None

            if next_low is None and next_high is None:
                break

            low_vol = bins[next_low].volume if next_low is not None else 0
            high_vol = bins[next_high].volume if next_high is not None else 0

            # Include the bin with more volume
            if low_vol >= high_vol and next_low is not None:
                low_idx = next_low
                current_volume += bins[low_idx].volume
            elif next_high is not None:
                high_idx = next_high
                current_volume += bins[high_idx].volume
            else:
                break

        vah = bins[high_idx].price_high
        val = bins[low_idx].price_low

        return vah, val

    def _find_high_volume_nodes(self, bins: List[VolumeBin], threshold_pct: float = 0.75) -> List[VolumeBin]:
        """Find bins with volume above threshold percentile."""
        if not bins:
            return []

        volumes = [b.volume for b in bins]
        if not volumes or max(volumes) == 0:
            return []

        # Calculate threshold
        sorted_vols = sorted(volumes)
        threshold_idx = int(len(sorted_vols) * threshold_pct)
        threshold = sorted_vols[min(threshold_idx, len(sorted_vols) - 1)]

        return [b for b in bins if b.volume >= threshold]

    def _find_low_volume_nodes(self, bins: List[VolumeBin], threshold_pct: float = 0.25) -> List[VolumeBin]:
        """Find bins with volume below threshold percentile."""
        if not bins:
            return []

        volumes = [b.volume for b in bins]
        if not volumes or max(volumes) == 0:
            return []

        # Calculate threshold
        sorted_vols = sorted(volumes)
        threshold_idx = int(len(sorted_vols) * threshold_pct)
        threshold = sorted_vols[min(threshold_idx, len(sorted_vols) - 1)]

        return [b for b in bins if b.volume <= threshold and b.volume > 0]

    def _get_support_from_hvn(self, current_price: float) -> Tuple[Optional[float], float]:
        """
        Get support level from high volume nodes below current price.

        Returns:
            Tuple of (support_level, confidence)
        """
        bins = self._build_volume_profile()
        hvns = self._find_high_volume_nodes(bins)

        # Filter HVNs below current price
        support_hvns = [h for h in hvns if h.price_mid < current_price]

        if not support_hvns:
            return None, 0.0

        # Closest HVN below price is likely support
        closest = max(support_hvns, key=lambda h: h.price_mid)

        # Confidence based on volume relative to total
        total_volume = sum(b.volume for b in bins)
        confidence = min(closest.volume / total_volume * 3, 1.0) if total_volume > 0 else 0.5

        return closest.price_mid, confidence

    def _get_resistance_from_hvn(self, current_price: float) -> Tuple[Optional[float], float]:
        """
        Get resistance level from high volume nodes above current price.

        Returns:
            Tuple of (resistance_level, confidence)
        """
        bins = self._build_volume_profile()
        hvns = self._find_high_volume_nodes(bins)

        # Filter HVNs above current price
        resistance_hvns = [h for h in hvns if h.price_mid > current_price]

        if not resistance_hvns:
            return None, 0.0

        # Closest HVN above price is likely resistance
        closest = min(resistance_hvns, key=lambda h: h.price_mid)

        # Confidence based on volume relative to total
        total_volume = sum(b.volume for b in bins)
        confidence = min(closest.volume / total_volume * 3, 1.0) if total_volume > 0 else 0.5

        return closest.price_mid, confidence

    def _is_in_low_volume_zone(self, current_price: float) -> bool:
        """Check if current price is in a low volume zone."""
        bins = self._build_volume_profile()
        if not bins:
            return False

        lvns = self._find_low_volume_nodes(bins)
        for lvn in lvns:
            if lvn.price_low <= current_price <= lvn.price_high:
                return True

        return False

    def analyze(self, current_price: float) -> VolumeProfileSignal:
        """
        Analyze current price against volume profile.

        Args:
            current_price: Current market price

        Returns:
            VolumeProfileSignal with key levels and signal
        """
        bins = self._build_volume_profile()

        # Check for insufficient data
        if len(self._prices) < 20 or not bins:
            return VolumeProfileSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                direction="neutral",
                support_level=None,
                resistance_level=None,
                point_of_control=None,
                value_area_high=None,
                value_area_low=None,
                support_confidence=0.0,
                resistance_confidence=0.0,
                poc_significance=0.0,
                current_price=current_price,
                near_poc=False,
                in_value_area=False,
                in_low_volume_zone=False,
            )

        # Get key levels
        poc = self.get_point_of_control()
        vah, val = self.get_value_area()
        support, support_conf = self._get_support_from_hvn(current_price)
        resistance, resistance_conf = self._get_resistance_from_hvn(current_price)

        # Calculate POC significance
        if bins:
            total_volume = sum(b.volume for b in bins)
            poc_bin = max(bins, key=lambda b: b.volume)
            poc_significance = poc_bin.volume / total_volume if total_volume > 0 else 0
        else:
            poc_significance = 0

        # Check current price position
        near_poc = poc is not None and abs(current_price - poc) / poc < 0.02  # Within 2%
        in_value_area = vah is not None and val is not None and val <= current_price <= vah
        in_low_volume_zone = self._is_in_low_volume_zone(current_price)

        # Determine signal type
        signal_type = "NO_SIGNAL"
        confidence = 0.0
        direction = "neutral"

        if in_low_volume_zone:
            signal_type = "VOLUME_BREAKOUT_ZONE"
            confidence = 0.6
            direction = "neutral"  # Can go either way
            logger.info(f"VOLUME BREAKOUT ZONE: price={current_price:.2f} in low volume area")
        elif near_poc:
            signal_type = "VOLUME_POC_BOUNCE"
            confidence = 0.65
            direction = "neutral"  # POC acts as magnet, direction depends on approach
            logger.info(f"VOLUME POC BOUNCE: price={current_price:.2f} near POC={poc:.2f}")
        elif support and support_conf > 0.5:
            # Near high volume support
            if abs(current_price - support) / support < 0.03:
                signal_type = "VOLUME_SUPPORT"
                confidence = support_conf
                direction = "long"
                logger.info(f"VOLUME SUPPORT: price={current_price:.2f} near support={support:.2f}")
        elif resistance and resistance_conf > 0.5:
            # Near high volume resistance
            if abs(current_price - resistance) / resistance < 0.03:
                signal_type = "VOLUME_RESISTANCE"
                confidence = resistance_conf
                direction = "short"
                logger.info(f"VOLUME RESISTANCE: price={current_price:.2f} near resistance={resistance:.2f}")

        return VolumeProfileSignal(
            signal_type=signal_type,
            confidence=confidence,
            direction=direction,
            support_level=support,
            resistance_level=resistance,
            point_of_control=poc,
            value_area_high=vah,
            value_area_low=val,
            support_confidence=support_conf,
            resistance_confidence=resistance_conf,
            poc_significance=poc_significance,
            current_price=current_price,
            near_poc=near_poc,
            in_value_area=in_value_area,
            in_low_volume_zone=in_low_volume_zone,
        )

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        poc = self.get_point_of_control()
        vah, val = self.get_value_area()

        return {
            'data_points': len(self._prices),
            'poc': poc,
            'value_area_high': vah,
            'value_area_low': val,
            'num_bins': self.num_bins,
            'lookback_period': self.lookback_period,
        }
