"""
Trailing Stop Strategy

Monitors open positions and triggers exit signals when price retraces
by a configurable percentage from its peak (for longs) or trough (for shorts).

Signals:
- TRAILING_STOP_HIT: Price has retraced beyond threshold, exit recommended
- TRAILING_STOP_WARNING: Price approaching stop level, caution advised
- NO_SIGNAL: Position is healthy
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)


@dataclass
class TrailingStopSignal:
    """
    Signal generated by trailing stop analysis.
    """
    signal_type: str  # TRAILING_STOP_HIT, TRAILING_STOP_WARNING, NO_SIGNAL
    confidence: float
    should_exit: bool
    symbol: str
    side: str  # long, short
    entry_price: float
    peak_price: float  # For longs
    trough_price: float  # For shorts
    current_price: float
    current_drawdown_pct: float
    stop_level: float
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'should_exit': self.should_exit,
            'symbol': self.symbol,
            'side': self.side,
            'entry_price': self.entry_price,
            'peak_price': self.peak_price,
            'trough_price': self.trough_price,
            'current_price': self.current_price,
            'current_drawdown_pct': self.current_drawdown_pct,
            'stop_level': self.stop_level,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class PositionState:
    """Internal state tracking for a position."""
    symbol: str
    side: str  # long, short
    entry_price: float
    peak_price: float  # Highest price since entry (for longs)
    trough_price: float  # Lowest price since entry (for shorts)
    opened_at: datetime = field(default_factory=datetime.utcnow)


class TrailingStopAnalyzer:
    """
    Trailing stop analyzer that tracks position peaks/troughs
    and generates exit signals on retracements.

    Configuration:
        trailing_stop_pct: Percentage retracement from peak/trough to trigger stop
                          (default 0.05 = 5%)
        warning_threshold_pct: Percentage at which to issue warning
                              (default 0.6 = 60% of stop distance)
    """

    def __init__(
        self,
        trailing_stop_pct: float = 0.05,
        warning_threshold_pct: float = 0.6,
    ):
        self.trailing_stop_pct = trailing_stop_pct
        self.warning_threshold_pct = warning_threshold_pct

        # Track positions by symbol
        self._positions: Dict[str, PositionState] = {}

        logger.info(
            f"TrailingStopAnalyzer initialized: stop={trailing_stop_pct:.1%}, "
            f"warning_at={warning_threshold_pct:.0%} of stop"
        )

    def open_position(
        self,
        symbol: str,
        side: str,
        entry_price: float,
    ) -> None:
        """
        Open a new position to track.

        Args:
            symbol: Trading symbol (e.g., 'BTC')
            side: 'long' or 'short'
            entry_price: Entry price of the position
        """
        self._positions[symbol] = PositionState(
            symbol=symbol,
            side=side.lower(),
            entry_price=entry_price,
            peak_price=entry_price,
            trough_price=entry_price,
        )
        logger.info(f"Trailing stop tracking started: {symbol} {side} @ ${entry_price:,.2f}")

    def close_position(self, symbol: str) -> None:
        """Stop tracking a position."""
        if symbol in self._positions:
            del self._positions[symbol]
            logger.info(f"Trailing stop tracking stopped: {symbol}")

    def update_price(self, symbol: str, price: float) -> None:
        """
        Update the current price for a position.
        Updates peak/trough as needed.

        Args:
            symbol: Trading symbol
            price: Current price
        """
        if symbol not in self._positions:
            return

        pos = self._positions[symbol]

        if pos.side == 'long':
            # Track new highs
            if price > pos.peak_price:
                pos.peak_price = price
                logger.debug(f"{symbol} new peak: ${price:,.2f}")
        else:  # short
            # Track new lows
            if price < pos.trough_price:
                pos.trough_price = price
                logger.debug(f"{symbol} new trough: ${price:,.2f}")

    def get_peak_price(self, symbol: str) -> Optional[float]:
        """Get the peak price for a position."""
        if symbol in self._positions:
            return self._positions[symbol].peak_price
        return None

    def get_trough_price(self, symbol: str) -> Optional[float]:
        """Get the trough price for a position."""
        if symbol in self._positions:
            return self._positions[symbol].trough_price
        return None

    def analyze(self, symbol: str, current_price: float) -> TrailingStopSignal:
        """
        Analyze current price against trailing stop levels.

        Args:
            symbol: Trading symbol
            current_price: Current market price

        Returns:
            TrailingStopSignal with exit recommendation
        """
        if symbol not in self._positions:
            return TrailingStopSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                should_exit=False,
                symbol=symbol,
                side="unknown",
                entry_price=0.0,
                peak_price=0.0,
                trough_price=0.0,
                current_price=current_price,
                current_drawdown_pct=0.0,
                stop_level=0.0,
            )

        pos = self._positions[symbol]

        # Update price tracking
        self.update_price(symbol, current_price)

        if pos.side == 'long':
            # For longs: drawdown from peak
            drawdown_pct = (pos.peak_price - current_price) / pos.peak_price
            stop_level = pos.peak_price * (1 - self.trailing_stop_pct)
            stop_triggered = current_price <= stop_level
            warning_level = pos.peak_price * (1 - self.trailing_stop_pct * self.warning_threshold_pct)
            in_warning_zone = current_price <= warning_level and not stop_triggered
        else:  # short
            # For shorts: adverse move from trough
            drawdown_pct = (current_price - pos.trough_price) / pos.trough_price
            stop_level = pos.trough_price * (1 + self.trailing_stop_pct)
            stop_triggered = current_price >= stop_level
            warning_level = pos.trough_price * (1 + self.trailing_stop_pct * self.warning_threshold_pct)
            in_warning_zone = current_price >= warning_level and not stop_triggered

        # Determine signal type
        if stop_triggered:
            signal_type = "TRAILING_STOP_HIT"
            confidence = 0.9
            should_exit = True
            logger.warning(
                f"TRAILING STOP HIT: {symbol} {pos.side} "
                f"drawdown={drawdown_pct:.2%}, stop=${stop_level:,.2f}"
            )
        elif in_warning_zone:
            signal_type = "TRAILING_STOP_WARNING"
            confidence = 0.5
            should_exit = False
            logger.info(
                f"Trailing stop warning: {symbol} {pos.side} "
                f"drawdown={drawdown_pct:.2%}, approaching stop"
            )
        else:
            signal_type = "NO_SIGNAL"
            confidence = 0.0
            should_exit = False

        return TrailingStopSignal(
            signal_type=signal_type,
            confidence=confidence,
            should_exit=should_exit,
            symbol=symbol,
            side=pos.side,
            entry_price=pos.entry_price,
            peak_price=pos.peak_price,
            trough_price=pos.trough_price,
            current_price=current_price,
            current_drawdown_pct=drawdown_pct,
            stop_level=stop_level,
        )

    def get_position_status(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Get current status of a tracked position."""
        if symbol not in self._positions:
            return None

        pos = self._positions[symbol]
        return {
            'symbol': pos.symbol,
            'side': pos.side,
            'entry_price': pos.entry_price,
            'peak_price': pos.peak_price,
            'trough_price': pos.trough_price,
            'opened_at': pos.opened_at.isoformat(),
        }

    def get_all_positions(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all tracked positions."""
        return {
            symbol: self.get_position_status(symbol)
            for symbol in self._positions
        }
