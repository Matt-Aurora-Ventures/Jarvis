"""
Take-Profit Strategy

Implements intelligent take-profit strategies including:
- Fixed percentage targets
- Scaled exit (sell in tranches)
- ATR-based dynamic targets
- Fibonacci retracement levels

Signals:
- TAKE_PROFIT_HIT: Price reached take-profit level
- TAKE_PROFIT_PARTIAL: Partial take-profit recommended
- APPROACHING_TP: Price nearing take-profit zone
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple
from enum import Enum

logger = logging.getLogger(__name__)


class TakeProfitType(Enum):
    """Take-profit calculation methods."""
    FIXED = "fixed"  # Fixed percentage from entry
    SCALED = "scaled"  # Multiple levels, sell portions
    ATR_BASED = "atr_based"  # Based on Average True Range
    FIBONACCI = "fibonacci"  # Fibonacci extension levels


@dataclass
class TakeProfitLevel:
    """A single take-profit level."""
    level_number: int
    price: float
    percentage_gain: float
    sell_portion: float  # 0-1, how much to sell at this level
    hit: bool = False
    hit_at: Optional[datetime] = None


@dataclass
class TakeProfitSignal:
    """
    Signal generated by take-profit analysis.
    """
    signal_type: str  # TAKE_PROFIT_HIT, TAKE_PROFIT_PARTIAL, APPROACHING_TP, NO_SIGNAL
    confidence: float
    should_sell: bool
    sell_portion: float  # 0-1, recommended portion to sell
    symbol: str
    side: str  # long, short
    entry_price: float
    current_price: float
    current_gain_pct: float
    tp_level_hit: Optional[int]  # Which TP level was hit
    next_tp_price: Optional[float]
    next_tp_gain_pct: Optional[float]
    all_levels: List[TakeProfitLevel] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'should_sell': self.should_sell,
            'sell_portion': self.sell_portion,
            'symbol': self.symbol,
            'side': self.side,
            'entry_price': self.entry_price,
            'current_price': self.current_price,
            'current_gain_pct': self.current_gain_pct,
            'tp_level_hit': self.tp_level_hit,
            'next_tp_price': self.next_tp_price,
            'next_tp_gain_pct': self.next_tp_gain_pct,
            'all_levels': [
                {
                    'level': l.level_number,
                    'price': l.price,
                    'gain_pct': l.percentage_gain,
                    'sell_portion': l.sell_portion,
                    'hit': l.hit,
                }
                for l in self.all_levels
            ],
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class PositionTPState:
    """Internal state tracking for a position's take-profit levels."""
    symbol: str
    side: str  # long, short
    entry_price: float
    tp_type: TakeProfitType
    levels: List[TakeProfitLevel]
    opened_at: datetime = field(default_factory=datetime.utcnow)


# Fibonacci extension levels (common targets)
FIBONACCI_EXTENSIONS = [0.236, 0.382, 0.5, 0.618, 1.0, 1.618, 2.618]

# Default scaled exit percentages and portions
DEFAULT_SCALED_LEVELS = [
    (0.10, 0.25),  # 10% gain -> sell 25%
    (0.20, 0.25),  # 20% gain -> sell 25%
    (0.35, 0.25),  # 35% gain -> sell 25%
    (0.50, 0.25),  # 50% gain -> sell remaining 25%
]


class TakeProfitAnalyzer:
    """
    Take-profit analyzer that calculates and monitors
    exit levels for positions.

    Configuration:
        tp_type: Type of take-profit calculation
        fixed_tp_pct: Fixed take-profit percentage (for FIXED type)
        scaled_levels: List of (gain_pct, sell_portion) tuples
        atr_multiplier: Multiplier for ATR-based targets
        approaching_threshold: How close to TP to trigger warning (0-1)
    """

    def __init__(
        self,
        tp_type: TakeProfitType = TakeProfitType.SCALED,
        fixed_tp_pct: float = 0.20,  # 20% default fixed TP
        scaled_levels: Optional[List[Tuple[float, float]]] = None,
        atr_multiplier: float = 3.0,
        approaching_threshold: float = 0.8,  # 80% of the way to TP
    ):
        self.tp_type = tp_type
        self.fixed_tp_pct = fixed_tp_pct
        self.scaled_levels = scaled_levels or DEFAULT_SCALED_LEVELS
        self.atr_multiplier = atr_multiplier
        self.approaching_threshold = approaching_threshold

        # Track positions by symbol
        self._positions: Dict[str, PositionTPState] = {}

        # ATR history for ATR-based calculations
        self._atr_values: Dict[str, float] = {}

        logger.info(
            f"TakeProfitAnalyzer initialized: type={tp_type.value}, "
            f"fixed_pct={fixed_tp_pct:.1%}"
        )

    def _calculate_tp_levels(
        self,
        entry_price: float,
        side: str,
        atr: Optional[float] = None,
    ) -> List[TakeProfitLevel]:
        """Calculate take-profit levels based on strategy type."""
        levels = []

        if self.tp_type == TakeProfitType.FIXED:
            # Single fixed level
            if side == "long":
                tp_price = entry_price * (1 + self.fixed_tp_pct)
            else:
                tp_price = entry_price * (1 - self.fixed_tp_pct)

            levels.append(TakeProfitLevel(
                level_number=1,
                price=tp_price,
                percentage_gain=self.fixed_tp_pct,
                sell_portion=1.0,  # Sell all at this level
            ))

        elif self.tp_type == TakeProfitType.SCALED:
            # Multiple levels with portions
            for i, (gain_pct, sell_portion) in enumerate(self.scaled_levels, 1):
                if side == "long":
                    tp_price = entry_price * (1 + gain_pct)
                else:
                    tp_price = entry_price * (1 - gain_pct)

                levels.append(TakeProfitLevel(
                    level_number=i,
                    price=tp_price,
                    percentage_gain=gain_pct,
                    sell_portion=sell_portion,
                ))

        elif self.tp_type == TakeProfitType.ATR_BASED:
            # ATR-based dynamic levels
            if atr is None:
                # Fallback to fixed if no ATR
                atr = entry_price * 0.02  # Assume 2% volatility

            multipliers = [1.5, 2.5, 3.5, 5.0]
            portions = [0.25, 0.25, 0.25, 0.25]

            for i, (mult, portion) in enumerate(zip(multipliers, portions), 1):
                tp_distance = atr * mult
                gain_pct = tp_distance / entry_price

                if side == "long":
                    tp_price = entry_price + tp_distance
                else:
                    tp_price = entry_price - tp_distance

                levels.append(TakeProfitLevel(
                    level_number=i,
                    price=tp_price,
                    percentage_gain=gain_pct,
                    sell_portion=portion,
                ))

        elif self.tp_type == TakeProfitType.FIBONACCI:
            # Fibonacci extension levels
            fib_levels = [0.236, 0.382, 0.618, 1.0]  # Common TP fibs
            portions = [0.20, 0.25, 0.30, 0.25]

            for i, (fib, portion) in enumerate(zip(fib_levels, portions), 1):
                if side == "long":
                    tp_price = entry_price * (1 + fib)
                else:
                    tp_price = entry_price * (1 - fib)

                levels.append(TakeProfitLevel(
                    level_number=i,
                    price=tp_price,
                    percentage_gain=fib,
                    sell_portion=portion,
                ))

        return levels

    def open_position(
        self,
        symbol: str,
        side: str,
        entry_price: float,
        atr: Optional[float] = None,
        custom_levels: Optional[List[Tuple[float, float]]] = None,
    ) -> List[TakeProfitLevel]:
        """
        Register a new position and calculate its take-profit levels.

        Args:
            symbol: Trading symbol
            side: 'long' or 'short'
            entry_price: Entry price
            atr: Average True Range (optional, for ATR-based TP)
            custom_levels: Override default levels with custom [(gain_pct, portion), ...]

        Returns:
            List of calculated take-profit levels
        """
        if custom_levels:
            original_levels = self.scaled_levels
            self.scaled_levels = custom_levels
            levels = self._calculate_tp_levels(entry_price, side, atr)
            self.scaled_levels = original_levels
        else:
            levels = self._calculate_tp_levels(entry_price, side, atr)

        if atr:
            self._atr_values[symbol] = atr

        state = PositionTPState(
            symbol=symbol,
            side=side,
            entry_price=entry_price,
            tp_type=self.tp_type,
            levels=levels,
        )

        self._positions[symbol] = state

        logger.info(
            f"Position opened with TP levels: {symbol} {side} @ {entry_price}, "
            f"levels: {[(l.percentage_gain, l.price) for l in levels]}"
        )

        return levels

    def close_position(self, symbol: str) -> None:
        """Remove position tracking."""
        if symbol in self._positions:
            del self._positions[symbol]
            logger.info(f"Position closed: {symbol}")
        if symbol in self._atr_values:
            del self._atr_values[symbol]

    def update_atr(self, symbol: str, atr: float) -> None:
        """Update ATR for dynamic TP recalculation."""
        self._atr_values[symbol] = atr

    def analyze(self, symbol: str, current_price: float) -> TakeProfitSignal:
        """
        Analyze current price against take-profit levels.

        Returns:
            TakeProfitSignal with recommendation
        """
        if symbol not in self._positions:
            return TakeProfitSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                should_sell=False,
                sell_portion=0.0,
                symbol=symbol,
                side="unknown",
                entry_price=0.0,
                current_price=current_price,
                current_gain_pct=0.0,
                tp_level_hit=None,
                next_tp_price=None,
                next_tp_gain_pct=None,
            )

        state = self._positions[symbol]
        entry = state.entry_price
        side = state.side
        levels = state.levels

        # Calculate current gain
        if side == "long":
            current_gain_pct = (current_price - entry) / entry
        else:
            current_gain_pct = (entry - current_price) / entry

        # Find the next unhit level
        next_level = None
        for level in levels:
            if not level.hit:
                next_level = level
                break

        # Check if any level is hit
        hit_level = None
        total_sell_portion = 0.0

        for level in levels:
            if level.hit:
                continue

            level_hit = False
            if side == "long" and current_price >= level.price:
                level_hit = True
            elif side == "short" and current_price <= level.price:
                level_hit = True

            if level_hit:
                level.hit = True
                level.hit_at = datetime.utcnow()
                hit_level = level
                total_sell_portion += level.sell_portion
                logger.info(
                    f"TP{level.level_number} HIT: {symbol} @ {current_price} "
                    f"(+{level.percentage_gain:.1%}), sell {level.sell_portion:.0%}"
                )

        # Recalculate next level after hits
        next_level = None
        for level in levels:
            if not level.hit:
                next_level = level
                break

        # Determine signal type
        if hit_level:
            # Check if all levels hit
            all_hit = all(l.hit for l in levels)

            if all_hit:
                signal_type = "TAKE_PROFIT_HIT"
                confidence = 1.0
            else:
                signal_type = "TAKE_PROFIT_PARTIAL"
                confidence = 0.85

            return TakeProfitSignal(
                signal_type=signal_type,
                confidence=confidence,
                should_sell=True,
                sell_portion=total_sell_portion,
                symbol=symbol,
                side=side,
                entry_price=entry,
                current_price=current_price,
                current_gain_pct=current_gain_pct,
                tp_level_hit=hit_level.level_number,
                next_tp_price=next_level.price if next_level else None,
                next_tp_gain_pct=next_level.percentage_gain if next_level else None,
                all_levels=levels,
            )

        # Check if approaching next TP
        if next_level and current_gain_pct > 0:
            progress_to_tp = current_gain_pct / next_level.percentage_gain

            if progress_to_tp >= self.approaching_threshold:
                logger.debug(
                    f"Approaching TP{next_level.level_number}: {symbol} "
                    f"@ {progress_to_tp:.0%} of target"
                )
                return TakeProfitSignal(
                    signal_type="APPROACHING_TP",
                    confidence=0.6,
                    should_sell=False,
                    sell_portion=0.0,
                    symbol=symbol,
                    side=side,
                    entry_price=entry,
                    current_price=current_price,
                    current_gain_pct=current_gain_pct,
                    tp_level_hit=None,
                    next_tp_price=next_level.price,
                    next_tp_gain_pct=next_level.percentage_gain,
                    all_levels=levels,
                )

        # No signal
        return TakeProfitSignal(
            signal_type="NO_SIGNAL",
            confidence=0.0,
            should_sell=False,
            sell_portion=0.0,
            symbol=symbol,
            side=side,
            entry_price=entry,
            current_price=current_price,
            current_gain_pct=current_gain_pct,
            tp_level_hit=None,
            next_tp_price=next_level.price if next_level else None,
            next_tp_gain_pct=next_level.percentage_gain if next_level else None,
            all_levels=levels,
        )

    def get_tp_levels(self, symbol: str) -> Optional[List[TakeProfitLevel]]:
        """Get current take-profit levels for a position."""
        if symbol in self._positions:
            return self._positions[symbol].levels
        return None

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        return {
            'tp_type': self.tp_type.value,
            'positions_tracked': len(self._positions),
            'fixed_tp_pct': self.fixed_tp_pct,
            'scaled_levels': len(self.scaled_levels),
            'positions': {
                sym: {
                    'side': s.side,
                    'entry': s.entry_price,
                    'levels_hit': sum(1 for l in s.levels if l.hit),
                    'total_levels': len(s.levels),
                }
                for sym, s in self._positions.items()
            },
        }


def calculate_fibonacci_levels(
    entry_price: float,
    swing_low: float,
    swing_high: float,
    side: str = "long",
) -> Dict[str, float]:
    """
    Calculate Fibonacci extension levels for take-profit targets.

    Args:
        entry_price: Current entry price
        swing_low: Recent swing low
        swing_high: Recent swing high
        side: 'long' or 'short'

    Returns:
        Dictionary of Fibonacci levels with prices
    """
    swing_range = swing_high - swing_low

    levels = {}
    for fib in FIBONACCI_EXTENSIONS:
        if side == "long":
            levels[f"fib_{fib}"] = swing_high + (swing_range * fib)
        else:
            levels[f"fib_{fib}"] = swing_low - (swing_range * fib)

    return levels
