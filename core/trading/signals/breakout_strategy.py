"""
Breakout Strategy

Identifies support/resistance levels and generates signals when price
breaks out above resistance or breaks down below support.

Key Features:
- Dynamic support/resistance detection from price history
- Volume confirmation for stronger signals
- False breakout detection

Signals:
- BREAKOUT_BUY: Price breaks above resistance with volume confirmation
- BREAKOUT_SELL: Price breaks below support with volume confirmation
- FALSE_BREAKOUT: Price reverses after breakout
- NO_SIGNAL: Price within range or insufficient data
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple

logger = logging.getLogger(__name__)


@dataclass
class BreakoutSignal:
    """
    Signal generated by breakout analysis.
    """
    signal_type: str  # BREAKOUT_BUY, BREAKOUT_SELL, FALSE_BREAKOUT, NO_SIGNAL
    confidence: float
    direction: str  # long, short, neutral

    # Level information
    breakout_level: Optional[float]
    breakdown_level: Optional[float]
    support_level: Optional[float]
    resistance_level: Optional[float]

    # Current state
    current_price: float
    current_volume: float
    avg_volume: float

    # Confirmation flags
    volume_confirmed: bool
    price_confirmed: bool

    # Metadata
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'direction': self.direction,
            'breakout_level': self.breakout_level,
            'breakdown_level': self.breakdown_level,
            'support_level': self.support_level,
            'resistance_level': self.resistance_level,
            'current_price': self.current_price,
            'current_volume': self.current_volume,
            'avg_volume': self.avg_volume,
            'volume_confirmed': self.volume_confirmed,
            'price_confirmed': self.price_confirmed,
            'timestamp': self.timestamp.isoformat(),
        }


class BreakoutAnalyzer:
    """
    Breakout analyzer that tracks support/resistance and generates signals.

    Configuration:
        lookback_period: Number of candles to analyze for S/R levels (default 20)
        breakout_threshold_pct: Minimum % above/below level to confirm breakout (default 0.02 = 2%)
        volume_confirmation_multiplier: Volume must be this times average (default 1.5)
    """

    def __init__(
        self,
        lookback_period: int = 20,
        breakout_threshold_pct: float = 0.02,
        volume_confirmation_multiplier: float = 1.5,
    ):
        self.lookback_period = lookback_period
        self.breakout_threshold_pct = breakout_threshold_pct
        self.volume_confirmation_multiplier = volume_confirmation_multiplier

        # Price and volume history
        self._prices: List[float] = []
        self._volumes: List[float] = []

        # Track recent breakouts for false breakout detection
        self._recent_breakout: Optional[Dict[str, Any]] = None

        logger.info(
            f"BreakoutAnalyzer initialized: lookback={lookback_period}, "
            f"threshold={breakout_threshold_pct:.1%}, volume_mult={volume_confirmation_multiplier}"
        )

    def add_data(self, price: float, volume: float) -> None:
        """
        Add a new price/volume observation.

        Args:
            price: Current price
            volume: Current volume
        """
        self._prices.append(price)
        self._volumes.append(volume)

        # Keep history bounded
        max_history = self.lookback_period * 3
        if len(self._prices) > max_history:
            self._prices = self._prices[-max_history:]
            self._volumes = self._volumes[-max_history:]

    def _find_swing_highs(self, prices: List[float], window: int = 3) -> List[Tuple[int, float]]:
        """Find local maxima (swing highs) in price data."""
        swing_highs = []
        if len(prices) < window * 2 + 1:
            return swing_highs

        for i in range(window, len(prices) - window):
            is_high = True
            for j in range(1, window + 1):
                if prices[i] <= prices[i - j] or prices[i] <= prices[i + j]:
                    is_high = False
                    break
            if is_high:
                swing_highs.append((i, prices[i]))

        return swing_highs

    def _find_swing_lows(self, prices: List[float], window: int = 3) -> List[Tuple[int, float]]:
        """Find local minima (swing lows) in price data."""
        swing_lows = []
        if len(prices) < window * 2 + 1:
            return swing_lows

        for i in range(window, len(prices) - window):
            is_low = True
            for j in range(1, window + 1):
                if prices[i] >= prices[i - j] or prices[i] >= prices[i + j]:
                    is_low = False
                    break
            if is_low:
                swing_lows.append((i, prices[i]))

        return swing_lows

    def _cluster_levels(self, levels: List[float], tolerance: float = 0.02) -> List[float]:
        """
        Cluster nearby price levels into zones.

        Args:
            levels: List of price levels
            tolerance: Maximum % difference to cluster

        Returns:
            List of clustered level centers
        """
        if not levels:
            return []

        levels = sorted(levels)
        clusters = []
        current_cluster = [levels[0]]

        for level in levels[1:]:
            if (level - current_cluster[-1]) / current_cluster[-1] <= tolerance:
                current_cluster.append(level)
            else:
                # Save average of cluster
                clusters.append(sum(current_cluster) / len(current_cluster))
                current_cluster = [level]

        # Don't forget the last cluster
        clusters.append(sum(current_cluster) / len(current_cluster))

        return clusters

    def get_resistance_level(self) -> Optional[float]:
        """
        Get the most significant resistance level.

        Returns:
            Resistance price level or None if insufficient data
        """
        if len(self._prices) < self.lookback_period:
            return None

        recent_prices = self._prices[-self.lookback_period:]
        swing_highs = self._find_swing_highs(recent_prices)

        if not swing_highs:
            # Fall back to recent high
            return max(recent_prices)

        # Get high values and cluster them
        high_values = [h[1] for h in swing_highs]

        # Count touches at each level (more touches = stronger resistance)
        if high_values:
            # Return the highest cluster (most recent resistance typically matters most)
            clusters = self._cluster_levels(high_values)
            if clusters:
                return max(clusters)

        return max(recent_prices)

    def get_support_level(self) -> Optional[float]:
        """
        Get the most significant support level.

        Returns:
            Support price level or None if insufficient data
        """
        if len(self._prices) < self.lookback_period:
            return None

        recent_prices = self._prices[-self.lookback_period:]
        swing_lows = self._find_swing_lows(recent_prices)

        if not swing_lows:
            # Fall back to recent low
            return min(recent_prices)

        # Get low values and cluster them
        low_values = [l[1] for l in swing_lows]

        if low_values:
            # Return the lowest cluster
            clusters = self._cluster_levels(low_values)
            if clusters:
                return min(clusters)

        return min(recent_prices)

    def _get_avg_volume(self) -> float:
        """Get average volume over lookback period."""
        if not self._volumes:
            return 0.0

        recent_volumes = self._volumes[-self.lookback_period:] if len(self._volumes) >= self.lookback_period else self._volumes
        return sum(recent_volumes) / len(recent_volumes)

    def analyze(self, current_price: float, current_volume: float) -> BreakoutSignal:
        """
        Analyze current price/volume for breakout signals.

        Args:
            current_price: Current market price
            current_volume: Current volume

        Returns:
            BreakoutSignal with signal type and details
        """
        resistance = self.get_resistance_level()
        support = self.get_support_level()
        avg_volume = self._get_avg_volume()

        # Check for insufficient data
        if resistance is None or support is None or len(self._prices) < self.lookback_period:
            return BreakoutSignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                direction="neutral",
                breakout_level=None,
                breakdown_level=None,
                support_level=support,
                resistance_level=resistance,
                current_price=current_price,
                current_volume=current_volume,
                avg_volume=avg_volume,
                volume_confirmed=False,
                price_confirmed=False,
            )

        # Check volume confirmation
        volume_confirmed = (
            avg_volume > 0 and
            current_volume >= avg_volume * self.volume_confirmation_multiplier
        )

        # Check for false breakout (recent breakout followed by reversal)
        if self._recent_breakout:
            rb = self._recent_breakout
            if rb['direction'] == 'long' and current_price < rb['level']:
                # Was above resistance, now back below
                logger.info(f"FALSE BREAKOUT detected: was above {rb['level']}, now at {current_price}")
                self._recent_breakout = None
                return BreakoutSignal(
                    signal_type="FALSE_BREAKOUT",
                    confidence=0.6,
                    direction="neutral",
                    breakout_level=rb['level'],
                    breakdown_level=None,
                    support_level=support,
                    resistance_level=resistance,
                    current_price=current_price,
                    current_volume=current_volume,
                    avg_volume=avg_volume,
                    volume_confirmed=volume_confirmed,
                    price_confirmed=False,
                )
            elif rb['direction'] == 'short' and current_price > rb['level']:
                # Was below support, now back above
                logger.info(f"FALSE BREAKDOWN detected: was below {rb['level']}, now at {current_price}")
                self._recent_breakout = None
                return BreakoutSignal(
                    signal_type="FALSE_BREAKOUT",
                    confidence=0.6,
                    direction="neutral",
                    breakout_level=None,
                    breakdown_level=rb['level'],
                    support_level=support,
                    resistance_level=resistance,
                    current_price=current_price,
                    current_volume=current_volume,
                    avg_volume=avg_volume,
                    volume_confirmed=volume_confirmed,
                    price_confirmed=False,
                )

        # Check for breakout above resistance
        breakout_threshold = resistance * (1 + self.breakout_threshold_pct)
        if current_price > breakout_threshold:
            # Confidence based on volume confirmation
            confidence = 0.75 if volume_confirmed else 0.55

            # Track this breakout for false breakout detection
            self._recent_breakout = {
                'direction': 'long',
                'level': resistance,
                'price': current_price,
            }

            logger.info(
                f"BREAKOUT BUY: price={current_price:.2f} > resistance={resistance:.2f}, "
                f"volume_confirmed={volume_confirmed}"
            )

            return BreakoutSignal(
                signal_type="BREAKOUT_BUY",
                confidence=confidence,
                direction="long",
                breakout_level=resistance,
                breakdown_level=None,
                support_level=support,
                resistance_level=resistance,
                current_price=current_price,
                current_volume=current_volume,
                avg_volume=avg_volume,
                volume_confirmed=volume_confirmed,
                price_confirmed=True,
            )

        # Check for breakdown below support
        breakdown_threshold = support * (1 - self.breakout_threshold_pct)
        if current_price < breakdown_threshold:
            # Confidence based on volume confirmation
            confidence = 0.75 if volume_confirmed else 0.55

            # Track this breakdown for false breakout detection
            self._recent_breakout = {
                'direction': 'short',
                'level': support,
                'price': current_price,
            }

            logger.info(
                f"BREAKOUT SELL: price={current_price:.2f} < support={support:.2f}, "
                f"volume_confirmed={volume_confirmed}"
            )

            return BreakoutSignal(
                signal_type="BREAKOUT_SELL",
                confidence=confidence,
                direction="short",
                breakout_level=None,
                breakdown_level=support,
                support_level=support,
                resistance_level=resistance,
                current_price=current_price,
                current_volume=current_volume,
                avg_volume=avg_volume,
                volume_confirmed=volume_confirmed,
                price_confirmed=True,
            )

        # Price within range
        return BreakoutSignal(
            signal_type="NO_SIGNAL",
            confidence=0.0,
            direction="neutral",
            breakout_level=None,
            breakdown_level=None,
            support_level=support,
            resistance_level=resistance,
            current_price=current_price,
            current_volume=current_volume,
            avg_volume=avg_volume,
            volume_confirmed=volume_confirmed,
            price_confirmed=False,
        )

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        return {
            'prices_tracked': len(self._prices),
            'volumes_tracked': len(self._volumes),
            'resistance_level': self.get_resistance_level(),
            'support_level': self.get_support_level(),
            'avg_volume': self._get_avg_volume(),
            'lookback_period': self.lookback_period,
            'breakout_threshold_pct': self.breakout_threshold_pct,
        }
