"""
DCA (Dollar Cost Averaging) Strategy

Implements a strategy for averaging down on positions during downtrends:
- Track average entry price
- Add to position on significant dips
- Limit max add-ons to avoid averaging into scams

Signals:
- DCA_ADD_OPPORTUNITY: Price has dipped enough to add
- DCA_MAX_ADDS_REACHED: Maximum add-ons hit, consider exiting
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

logger = logging.getLogger(__name__)


@dataclass
class DCASignal:
    """
    Signal generated by DCA analysis.
    """
    signal_type: str  # DCA_ADD_OPPORTUNITY, DCA_MAX_ADDS_REACHED, NO_SIGNAL
    confidence: float
    should_exit: bool
    symbol: str
    average_entry: float
    current_price: float
    current_drawdown_pct: float
    add_count: int
    max_adds: int
    recommended_size: float  # Size relative to original position
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'signal_type': self.signal_type,
            'confidence': self.confidence,
            'should_exit': self.should_exit,
            'symbol': self.symbol,
            'average_entry': self.average_entry,
            'current_price': self.current_price,
            'current_drawdown_pct': self.current_drawdown_pct,
            'add_count': self.add_count,
            'max_adds': self.max_adds,
            'recommended_size': self.recommended_size,
            'timestamp': self.timestamp.isoformat(),
        }


@dataclass
class DCAPosition:
    """Internal state for a DCA position."""
    symbol: str
    entries: List[Dict[str, float]]  # List of {price, size}
    total_size: float
    total_cost: float
    add_count: int
    original_size: float
    opened_at: datetime = field(default_factory=datetime.utcnow)

    @property
    def average_entry(self) -> float:
        """Calculate weighted average entry price."""
        if self.total_size == 0:
            return 0.0
        return self.total_cost / self.total_size


class DCAAnalyzer:
    """
    Dollar Cost Averaging analyzer for position management.

    Configuration:
        dip_threshold_pct: Percentage drop from average entry to trigger DCA
                          (default 0.10 = 10%)
        max_add_ons: Maximum number of add-on buys (default 3)
        add_on_size_pct: Size of add-on relative to original (default 0.50 = 50%)
    """

    def __init__(
        self,
        dip_threshold_pct: float = 0.10,
        max_add_ons: int = 3,
        add_on_size_pct: float = 0.50,
    ):
        self.dip_threshold_pct = dip_threshold_pct
        self.max_add_ons = max_add_ons
        self.add_on_size_pct = add_on_size_pct

        # Track positions by symbol
        self._positions: Dict[str, DCAPosition] = {}

        logger.info(
            f"DCAAnalyzer initialized: dip_threshold={dip_threshold_pct:.0%}, "
            f"max_adds={max_add_ons}, add_size={add_on_size_pct:.0%}"
        )

    def open_position(
        self,
        symbol: str,
        entry_price: float,
        size: float,
    ) -> None:
        """
        Open a new DCA-tracked position.

        Args:
            symbol: Trading symbol (e.g., 'BTC')
            entry_price: Initial entry price
            size: Initial position size
        """
        self._positions[symbol] = DCAPosition(
            symbol=symbol,
            entries=[{'price': entry_price, 'size': size}],
            total_size=size,
            total_cost=entry_price * size,
            add_count=0,
            original_size=size,
        )
        logger.info(
            f"DCA position opened: {symbol} @ ${entry_price:,.2f}, size={size}"
        )

    def add_to_position(
        self,
        symbol: str,
        add_price: float,
        add_size: float,
    ) -> bool:
        """
        Add to an existing position (DCA buy).

        Args:
            symbol: Trading symbol
            add_price: Price at which to add
            add_size: Size to add

        Returns:
            True if add was successful, False if max adds reached
        """
        if symbol not in self._positions:
            logger.warning(f"No position found for {symbol}")
            return False

        pos = self._positions[symbol]

        if pos.add_count >= self.max_add_ons:
            logger.warning(f"Max DCA adds reached for {symbol}")
            return False

        pos.entries.append({'price': add_price, 'size': add_size})
        pos.total_size += add_size
        pos.total_cost += add_price * add_size
        pos.add_count += 1

        logger.info(
            f"DCA add #{pos.add_count}: {symbol} @ ${add_price:,.2f}, "
            f"size={add_size}, new_avg=${pos.average_entry:,.2f}"
        )

        return True

    def close_position(self, symbol: str) -> None:
        """Close and stop tracking a position."""
        if symbol in self._positions:
            del self._positions[symbol]
            logger.info(f"DCA position closed: {symbol}")

    def get_average_entry(self, symbol: str) -> Optional[float]:
        """Get average entry price for a position."""
        if symbol in self._positions:
            return self._positions[symbol].average_entry
        return None

    def get_add_count(self, symbol: str) -> int:
        """Get number of DCA adds for a position."""
        if symbol in self._positions:
            return self._positions[symbol].add_count
        return 0

    def analyze(self, symbol: str, current_price: float) -> DCASignal:
        """
        Analyze whether to add to position via DCA.

        Args:
            symbol: Trading symbol
            current_price: Current market price

        Returns:
            DCASignal with DCA recommendation
        """
        if symbol not in self._positions:
            return DCASignal(
                signal_type="NO_SIGNAL",
                confidence=0.0,
                should_exit=False,
                symbol=symbol,
                average_entry=0.0,
                current_price=current_price,
                current_drawdown_pct=0.0,
                add_count=0,
                max_adds=self.max_add_ons,
                recommended_size=0.0,
            )

        pos = self._positions[symbol]
        avg_entry = pos.average_entry

        # Calculate drawdown from average entry
        drawdown_pct = (avg_entry - current_price) / avg_entry

        # Check if max adds reached
        if pos.add_count >= self.max_add_ons:
            # Already at max adds - if still falling, suggest exit
            if drawdown_pct > self.dip_threshold_pct:
                logger.warning(
                    f"DCA MAX ADDS REACHED for {symbol}: "
                    f"drawdown={drawdown_pct:.1%}, consider exit"
                )
                return DCASignal(
                    signal_type="DCA_MAX_ADDS_REACHED",
                    confidence=0.8,
                    should_exit=True,
                    symbol=symbol,
                    average_entry=avg_entry,
                    current_price=current_price,
                    current_drawdown_pct=drawdown_pct,
                    add_count=pos.add_count,
                    max_adds=self.max_add_ons,
                    recommended_size=0.0,
                )
            else:
                return DCASignal(
                    signal_type="NO_SIGNAL",
                    confidence=0.0,
                    should_exit=False,
                    symbol=symbol,
                    average_entry=avg_entry,
                    current_price=current_price,
                    current_drawdown_pct=drawdown_pct,
                    add_count=pos.add_count,
                    max_adds=self.max_add_ons,
                    recommended_size=0.0,
                )

        # Check if price has dipped enough for DCA opportunity
        if drawdown_pct >= self.dip_threshold_pct:
            recommended_size = pos.original_size * self.add_on_size_pct
            logger.info(
                f"DCA OPPORTUNITY: {symbol} drawdown={drawdown_pct:.1%}, "
                f"recommend adding size={recommended_size}"
            )
            return DCASignal(
                signal_type="DCA_ADD_OPPORTUNITY",
                confidence=0.7,
                should_exit=False,
                symbol=symbol,
                average_entry=avg_entry,
                current_price=current_price,
                current_drawdown_pct=drawdown_pct,
                add_count=pos.add_count,
                max_adds=self.max_add_ons,
                recommended_size=recommended_size,
            )

        # No signal - price hasn't dipped enough
        return DCASignal(
            signal_type="NO_SIGNAL",
            confidence=0.0,
            should_exit=False,
            symbol=symbol,
            average_entry=avg_entry,
            current_price=current_price,
            current_drawdown_pct=drawdown_pct,
            add_count=pos.add_count,
            max_adds=self.max_add_ons,
            recommended_size=0.0,
        )

    def get_position_status(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Get current status of a DCA position."""
        if symbol not in self._positions:
            return None

        pos = self._positions[symbol]
        return {
            'symbol': pos.symbol,
            'average_entry': pos.average_entry,
            'total_size': pos.total_size,
            'total_cost': pos.total_cost,
            'add_count': pos.add_count,
            'max_adds': self.max_add_ons,
            'original_size': pos.original_size,
            'entries': pos.entries,
            'opened_at': pos.opened_at.isoformat(),
        }

    def get_all_positions(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all DCA positions."""
        return {
            symbol: self.get_position_status(symbol)
            for symbol in self._positions
        }

    def get_stats(self) -> Dict[str, Any]:
        """Get analyzer statistics."""
        total_adds = sum(p.add_count for p in self._positions.values())
        return {
            'positions_tracked': len(self._positions),
            'total_dca_adds': total_adds,
            'dip_threshold_pct': self.dip_threshold_pct,
            'max_add_ons': self.max_add_ons,
            'add_on_size_pct': self.add_on_size_pct,
        }
