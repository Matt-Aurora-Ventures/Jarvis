"""
Base Trading Strategy
Prompt #83: Treasury Strategy Manager - Base classes and interfaces

Provides the abstract base class for all trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional


# =============================================================================
# ENUMS
# =============================================================================

class SignalType(str, Enum):
    """Type of trading signal"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"  # Close existing position


class TimeFrame(str, Enum):
    """Analysis timeframe"""
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    H1 = "1h"
    H4 = "4h"
    D1 = "1d"


class MarketCondition(str, Enum):
    """Current market condition"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    SIDEWAYS = "sideways"
    VOLATILE = "volatile"
    LOW_VOLUME = "low_volume"


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass
class StrategyConfig:
    """Configuration for a trading strategy"""
    name: str
    version: str = "1.0.0"
    enabled: bool = True

    # Allocation limits
    max_allocation_pct: float = 0.20  # Max 20% of active capital
    max_position_count: int = 5
    max_position_size_pct: float = 0.05  # 5% per position

    # Risk parameters
    max_drawdown_pct: float = 0.10  # 10% max drawdown
    stop_loss_pct: float = 0.05     # 5% stop loss
    take_profit_pct: float = 0.15   # 15% take profit

    # Timing
    min_interval_seconds: int = 300  # 5 min between trades
    cooldown_after_loss_seconds: int = 3600  # 1 hour after loss

    # Strategy-specific parameters
    parameters: Dict[str, Any] = field(default_factory=dict)

    # Metadata
    description: str = ""
    author: str = ""
    tags: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "version": self.version,
            "enabled": self.enabled,
            "max_allocation_pct": self.max_allocation_pct,
            "max_position_count": self.max_position_count,
            "max_position_size_pct": self.max_position_size_pct,
            "max_drawdown_pct": self.max_drawdown_pct,
            "stop_loss_pct": self.stop_loss_pct,
            "take_profit_pct": self.take_profit_pct,
            "parameters": self.parameters,
            "tags": self.tags,
        }


@dataclass
class MarketData:
    """Market data for strategy analysis"""
    token_mint: str
    symbol: str
    timestamp: datetime

    # Price data
    price: Decimal
    price_24h_ago: Optional[Decimal] = None
    price_1h_ago: Optional[Decimal] = None
    high_24h: Optional[Decimal] = None
    low_24h: Optional[Decimal] = None

    # Volume
    volume_24h: Optional[Decimal] = None
    volume_1h: Optional[Decimal] = None
    volume_avg_24h: Optional[Decimal] = None

    # Market metrics
    market_cap: Optional[Decimal] = None
    liquidity: Optional[Decimal] = None
    holders: Optional[int] = None

    # Technical indicators (pre-calculated)
    rsi_14: Optional[float] = None
    macd: Optional[float] = None
    macd_signal: Optional[float] = None
    sma_20: Optional[Decimal] = None
    sma_50: Optional[Decimal] = None
    ema_12: Optional[Decimal] = None
    ema_26: Optional[Decimal] = None
    bollinger_upper: Optional[Decimal] = None
    bollinger_lower: Optional[Decimal] = None

    # Derived metrics
    @property
    def price_change_24h(self) -> Optional[float]:
        if self.price and self.price_24h_ago and self.price_24h_ago > 0:
            return float((self.price - self.price_24h_ago) / self.price_24h_ago)
        return None

    @property
    def price_change_1h(self) -> Optional[float]:
        if self.price and self.price_1h_ago and self.price_1h_ago > 0:
            return float((self.price - self.price_1h_ago) / self.price_1h_ago)
        return None

    @property
    def volume_ratio(self) -> Optional[float]:
        if self.volume_1h and self.volume_avg_24h and self.volume_avg_24h > 0:
            return float(self.volume_1h / (self.volume_avg_24h / 24))
        return None

    @property
    def volatility_24h(self) -> Optional[float]:
        if self.high_24h and self.low_24h and self.price and self.price > 0:
            return float((self.high_24h - self.low_24h) / self.price)
        return None


@dataclass
class TradeSignal:
    """Signal generated by a strategy"""
    strategy_name: str
    signal_type: SignalType
    token_mint: str
    symbol: str

    # Sizing
    confidence: float  # 0.0 to 1.0
    suggested_size_pct: float  # Suggested position size as % of capital

    # Reasoning
    reason: str
    indicators_used: List[str] = field(default_factory=list)

    # Risk management
    stop_loss_price: Optional[Decimal] = None
    take_profit_price: Optional[Decimal] = None

    # Metadata
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    market_data: Optional[MarketData] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "strategy": self.strategy_name,
            "signal": self.signal_type.value,
            "token_mint": self.token_mint,
            "symbol": self.symbol,
            "confidence": self.confidence,
            "suggested_size_pct": self.suggested_size_pct,
            "reason": self.reason,
            "indicators_used": self.indicators_used,
            "stop_loss_price": str(self.stop_loss_price) if self.stop_loss_price else None,
            "take_profit_price": str(self.take_profit_price) if self.take_profit_price else None,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class StrategyPosition:
    """A position opened by a strategy"""
    strategy_name: str
    token_mint: str
    symbol: str

    entry_price: Decimal
    entry_time: datetime
    size_tokens: int
    size_sol: Decimal

    # Risk levels
    stop_loss_price: Optional[Decimal] = None
    take_profit_price: Optional[Decimal] = None

    # Current state
    current_price: Optional[Decimal] = None
    unrealized_pnl: Optional[Decimal] = None
    unrealized_pnl_pct: Optional[float] = None

    # Exit
    exit_price: Optional[Decimal] = None
    exit_time: Optional[datetime] = None
    realized_pnl: Optional[Decimal] = None
    exit_reason: Optional[str] = None

    @property
    def is_open(self) -> bool:
        return self.exit_time is None


# =============================================================================
# ABSTRACT BASE CLASS
# =============================================================================

class TradingStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Subclasses must implement:
    - analyze(): Generate trading signals
    - should_exit(): Check if position should be closed
    - on_trade_executed(): Handle trade execution callback

    Optional overrides:
    - on_position_update(): Handle position updates
    - on_market_data(): Handle market data updates
    """

    def __init__(self, config: StrategyConfig):
        self.config = config
        self.positions: Dict[str, StrategyPosition] = {}
        self.last_trade_time: Optional[datetime] = None
        self.last_loss_time: Optional[datetime] = None
        self._enabled = config.enabled

    @property
    def name(self) -> str:
        return self.config.name

    @property
    def is_enabled(self) -> bool:
        return self._enabled

    def enable(self):
        """Enable the strategy"""
        self._enabled = True

    def disable(self):
        """Disable the strategy"""
        self._enabled = False

    # =========================================================================
    # ABSTRACT METHODS
    # =========================================================================

    @abstractmethod
    async def analyze(self, market_data: MarketData) -> Optional[TradeSignal]:
        """
        Analyze market data and generate a trading signal.

        Args:
            market_data: Current market data

        Returns:
            TradeSignal if action should be taken, None otherwise
        """
        pass

    @abstractmethod
    async def should_exit(
        self,
        position: StrategyPosition,
        market_data: MarketData,
    ) -> Optional[TradeSignal]:
        """
        Check if an existing position should be closed.

        Args:
            position: The current position
            market_data: Current market data

        Returns:
            TradeSignal with SELL/CLOSE if should exit, None otherwise
        """
        pass

    @abstractmethod
    async def on_trade_executed(self, result: Dict[str, Any]):
        """
        Callback when a trade is executed.

        Args:
            result: Trade execution result
        """
        pass

    # =========================================================================
    # REQUIRED DATA
    # =========================================================================

    @property
    @abstractmethod
    def required_indicators(self) -> List[str]:
        """List of technical indicators required by this strategy"""
        pass

    @property
    def required_timeframes(self) -> List[TimeFrame]:
        """Timeframes needed for analysis (default: 1h)"""
        return [TimeFrame.H1]

    # =========================================================================
    # OPTIONAL HOOKS
    # =========================================================================

    async def on_position_update(self, position: StrategyPosition):
        """Called when position state updates (price change, etc.)"""
        pass

    async def on_market_data(self, market_data: MarketData):
        """Called when new market data arrives"""
        pass

    async def initialize(self):
        """Called when strategy is loaded"""
        pass

    async def shutdown(self):
        """Called when strategy is being disabled/unloaded"""
        pass

    # =========================================================================
    # POSITION MANAGEMENT
    # =========================================================================

    def add_position(self, position: StrategyPosition):
        """Track a new position"""
        self.positions[position.token_mint] = position

    def get_position(self, token_mint: str) -> Optional[StrategyPosition]:
        """Get position for a token"""
        return self.positions.get(token_mint)

    def close_position(self, token_mint: str, exit_price: Decimal, reason: str):
        """Mark a position as closed"""
        position = self.positions.get(token_mint)
        if position:
            position.exit_time = datetime.now(timezone.utc)
            position.exit_price = exit_price
            position.exit_reason = reason

            if position.entry_price > 0:
                position.realized_pnl = (exit_price - position.entry_price) * position.size_tokens

            # Track loss for cooldown
            if position.realized_pnl and position.realized_pnl < 0:
                self.last_loss_time = datetime.now(timezone.utc)

    def get_open_positions(self) -> List[StrategyPosition]:
        """Get all open positions"""
        return [p for p in self.positions.values() if p.is_open]

    def get_position_count(self) -> int:
        """Get count of open positions"""
        return len(self.get_open_positions())

    # =========================================================================
    # TIMING CHECKS
    # =========================================================================

    def can_trade(self) -> tuple[bool, str]:
        """Check if strategy can trade based on timing rules"""
        now = datetime.now(timezone.utc)

        # Check min interval
        if self.last_trade_time:
            elapsed = (now - self.last_trade_time).total_seconds()
            if elapsed < self.config.min_interval_seconds:
                return False, f"Min interval not met ({elapsed:.0f}s < {self.config.min_interval_seconds}s)"

        # Check cooldown after loss
        if self.last_loss_time:
            elapsed = (now - self.last_loss_time).total_seconds()
            if elapsed < self.config.cooldown_after_loss_seconds:
                return False, f"Loss cooldown active ({elapsed:.0f}s < {self.config.cooldown_after_loss_seconds}s)"

        # Check position count
        if self.get_position_count() >= self.config.max_position_count:
            return False, f"Max positions reached ({self.get_position_count()}/{self.config.max_position_count})"

        return True, "OK"

    def record_trade(self):
        """Record that a trade was made"""
        self.last_trade_time = datetime.now(timezone.utc)

    # =========================================================================
    # POSITION SIZING
    # =========================================================================

    def calculate_position_size(
        self,
        signal: TradeSignal,
        available_capital: Decimal,
    ) -> Decimal:
        """
        Calculate position size based on signal and limits.

        Args:
            signal: The trade signal
            available_capital: Available capital for trading

        Returns:
            Position size in SOL
        """
        # Start with suggested size
        size_pct = min(signal.suggested_size_pct, self.config.max_position_size_pct)

        # Adjust by confidence
        size_pct *= signal.confidence

        # Calculate amount
        amount = available_capital * Decimal(str(size_pct))

        return amount

    # =========================================================================
    # STATS
    # =========================================================================

    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics"""
        open_positions = self.get_open_positions()
        closed_positions = [p for p in self.positions.values() if not p.is_open]

        wins = len([p for p in closed_positions if p.realized_pnl and p.realized_pnl > 0])
        losses = len([p for p in closed_positions if p.realized_pnl and p.realized_pnl < 0])
        total_pnl = sum(p.realized_pnl or Decimal(0) for p in closed_positions)

        return {
            "name": self.name,
            "enabled": self.is_enabled,
            "open_positions": len(open_positions),
            "total_trades": len(closed_positions),
            "wins": wins,
            "losses": losses,
            "win_rate": wins / len(closed_positions) if closed_positions else 0,
            "total_pnl": float(total_pnl),
            "last_trade": self.last_trade_time.isoformat() if self.last_trade_time else None,
        }
