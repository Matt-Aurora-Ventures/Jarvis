#!/usr/bin/env python3
"""
Telegram Rekey + Group Rebootstrap (Windows, Telegram Desktop session)

What this does (non-interactive):
1. Uses your *Telegram Desktop* session (tdata) to authenticate a Telethon user client.
2. Creates fresh bot tokens via @BotFather for the Jarvis + ClawdBots suite.
3. Detects the target private group (defaults to the only group found, or by title match).
4. Invites the newly-created bots into that group.
5. Writes/updates local config files:
   - tg_bot/.env (chat IDs + admin IDs + main bot tokens)
   - tokens.env (ClawdBots tokens)
   - allowlist.vps.json (Telegram admin user ID)
6. Writes secret "update bundles" under secrets/ for deploying to VPS hosts.

Safety:
- Never prints tokens to stdout.
- Writes secrets only to gitignored files (secrets/, tg_bot/.env, tokens.env).
"""

from __future__ import annotations

import argparse
import json
import os
import random
import re
import string
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple


TOKEN_RE = re.compile(r"(\d+:[A-Za-z0-9_-]{30,})")
BOTFATHER_RETRY_RE = re.compile(r"try again in (\d+)\s*seconds", re.IGNORECASE)


class BotFatherRetryAfter(RuntimeError):
    def __init__(self, seconds: int, message: str):
        super().__init__(message)
        self.seconds = int(seconds)


@dataclass(frozen=True)
class BotSpec:
    env_var: str
    name: str
    username_base: str


@dataclass(frozen=True)
class CreatedBot:
    env_var: str
    name: str
    username: str
    token: str
    source: str = "unknown"


def _random_suffix(n: int = 6) -> str:
    return "".join(random.choice(string.digits) for _ in range(n))


def _normalize_username(u: str) -> str:
    u = (u or "").strip()
    if u.startswith("@"):
        u = u[1:]
    u = u.replace(" ", "_")
    if not u.lower().endswith("bot"):
        u = f"{u}_bot"
    # Telegram constraints: 5-32 chars, letters/digits/underscore, must end in bot.
    u = re.sub(r"[^A-Za-z0-9_]", "_", u)
    u = u[:32]
    if len(u) < 5:
        u = (u + "_bot")[:5]
    if not u.lower().endswith("bot"):
        u = (u[:29] + "bot") if len(u) >= 3 else (u + "bot")
    return u


def _mask(s: str) -> str:
    if not s:
        return ""
    if len(s) <= 10:
        return s[:2] + "***"
    return s[:4] + "..." + s[-4:]


def _parse_botfather_retry_seconds(text: str) -> Optional[int]:
    if not text:
        return None
    m = BOTFATHER_RETRY_RE.search(text)
    if not m:
        return None
    try:
        return int(m.group(1))
    except Exception:
        return None


def _bot_api_get_username(token: str) -> str:
    """Resolve a bot username from a Bot API token (also validates token)."""
    import json as _json
    import urllib.error
    import urllib.request

    url = f"https://api.telegram.org/bot{token}/getMe"
    try:
        with urllib.request.urlopen(url, timeout=20) as resp:
            data = _json.loads(resp.read().decode("utf-8", errors="replace"))
    except urllib.error.HTTPError as e:
        body = (e.read() or b"").decode("utf-8", errors="replace")
        raise RuntimeError(f"Bot API getMe failed (HTTP {e.code}): {body[:200]}") from e
    if not data.get("ok"):
        raise RuntimeError(f"Bot API getMe failed: {str(data)[:200]}")
    result = data.get("result") or {}
    username = (result.get("username") or "").strip()
    if not username:
        raise RuntimeError("Bot API getMe returned empty username")
    return username


def _repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _default_tdata_path() -> Path:
    appdata = os.environ.get("APPDATA")
    if appdata:
        return Path(appdata) / "Telegram Desktop" / "tdata"
    # Fallback: common Windows path
    return Path.home() / "AppData" / "Roaming" / "Telegram Desktop" / "tdata"


def _ensure_secrets_dir(root: Path) -> Path:
    d = root / "secrets"
    d.mkdir(parents=True, exist_ok=True)
    return d


def _read_env_file(path: Path) -> Tuple[List[str], Dict[str, int]]:
    """Return (lines, index_by_key). Keeps original formatting as much as possible."""
    if not path.exists():
        return ([], {})
    lines = path.read_text(encoding="utf-8", errors="replace").splitlines()
    index: Dict[str, int] = {}
    for i, line in enumerate(lines):
        s = line.strip()
        if not s or s.startswith("#") or "=" not in s:
            continue
        k, _ = s.split("=", 1)
        k = k.strip()
        if k and k not in index:
            index[k] = i
    return (lines, index)


def _upsert_env(path: Path, updates: Dict[str, str]) -> None:
    lines, index = _read_env_file(path)
    if not lines:
        lines = [
            "# Auto-generated by scripts/telegram_rekey_bots.py",
            "# IMPORTANT: do not commit this file",
            "",
        ]
        index = {}

    for k, v in updates.items():
        line = f"{k}={v}"
        if k in index:
            lines[index[k]] = line
        else:
            lines.append(line)
            index[k] = len(lines) - 1

    # Ensure final newline
    path.write_text("\n".join(lines).rstrip("\n") + "\n", encoding="utf-8")


def _write_update_bundle(path: Path, updates: Dict[str, str]) -> None:
    # Write as KEY=VALUE lines, stable ordering.
    lines = [f"{k}={updates[k]}" for k in sorted(updates.keys())]
    path.write_text("\n".join(lines).rstrip("\n") + "\n", encoding="utf-8")


def _load_env_kv(path: Path) -> Dict[str, str]:
    """Load KEY=VALUE pairs from a dotenv-ish file (ignores comments/blank lines)."""
    if not path.exists():
        return {}
    kv: Dict[str, str] = {}
    for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = (k or "").strip()
        v = (v or "").strip()
        if k:
            kv[k] = v
    return kv


def _update_allowlist_user_id(path: Path, new_user_id: int, name: str = "Matt") -> None:
    data = {}
    if path.exists():
        data = json.loads(path.read_text(encoding="utf-8"))

    users = data.get("users") or {}
    # If there's exactly one user and it's different, migrate it.
    if str(new_user_id) not in users:
        if len(users) == 1:
            (_, v), = users.items()
            users = {str(new_user_id): v}
        else:
            users[str(new_user_id)] = {
                "name": name,
                "role": "founder",
                "added_at": None,
            }

    data["users"] = users
    path.write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")


def _bot_api_chat_id(entity) -> Optional[int]:
    """Convert Telethon entity to Bot API style chat_id."""
    cls = entity.__class__.__name__
    try:
        if cls == "Channel":
            # supergroup/channel ids are -100{channel_id}
            return int("-100" + str(int(entity.id)))
        if cls == "Chat":
            # basic group ids are negative chat id
            return -int(entity.id)
    except Exception:
        return None
    return None


async def _telethon_client_from_tdesktop(tdata_path: Path, session_name: str):
    # OpenTele can't parse some newer Telegram Desktop "map" key types; ignore them.
    from opentele.td import TDesktop, API
    from opentele.td.account import MapData
    from opentele.exception import TDataReadMapDataFailed

    orig_read = MapData.read

    def patched_read(self, localKey, legacyPasscode=None):  # noqa: N802 - external API
        try:
            return orig_read(self, localKey, legacyPasscode)
        except TDataReadMapDataFailed as e:
            if "Unknown key type" in str(e):
                return None
            raise

    MapData.read = patched_read  # type: ignore[assignment]

    td = TDesktop(str(tdata_path))
    client = await td.ToTelethon(session=session_name, api=API.TelegramDesktop)
    return client


async def _botfather_send(client, botfather, text: str) -> None:
    import asyncio

    from telethon.errors import FloodWaitError

    while True:
        try:
            await client.send_message(botfather, text)
            return
        except FloodWaitError as e:
            await asyncio.sleep(int(getattr(e, "seconds", 1)) + 1)


async def _botfather_cursor(client, botfather) -> int:
    last = await client.get_messages(botfather, limit=1)
    return int(last[0].id) if last else 0


async def _botfather_wait_for_message(client, botfather, min_id: int, timeout_s: int, pred):
    """Poll BotFather chat history until pred(message) is True; returns (message, new_min_id)."""
    import asyncio
    import time

    deadline = time.monotonic() + timeout_s
    cur = int(min_id)
    while time.monotonic() < deadline:
        msgs = await client.get_messages(botfather, min_id=cur, limit=50)
        if msgs:
            msgs_sorted = sorted(msgs, key=lambda m: int(getattr(m, "id", 0)))
            cur = max(int(getattr(m, "id", 0)) for m in msgs_sorted)
            for m in msgs_sorted:
                if getattr(m, "out", False):
                    continue
                txt = (getattr(m, "raw_text", None) or "").strip()
                lower = txt.lower()
                if "too many attempts" in lower:
                    secs = _parse_botfather_retry_seconds(txt) or 0
                    raise BotFatherRetryAfter(secs, txt)
                if pred(m):
                    return m, cur

        await asyncio.sleep(1.0)
    raise TimeoutError("BotFather reply timed out")


async def _botfather_wait_for_text(client, botfather, min_id: int, timeout_s: int, pred_text):
    """Like _botfather_wait_for_message, but pred_text(text) predicate and returns (text, new_min_id)."""

    def pred(m) -> bool:
        txt = (getattr(m, "raw_text", None) or "").strip()
        if not txt:
            return False
        return bool(pred_text(txt))

    m, cur = await _botfather_wait_for_message(client, botfather, min_id=min_id, timeout_s=timeout_s, pred=pred)
    return ((getattr(m, "raw_text", None) or "").strip(), cur)


async def _botfather_list_bots(client) -> List[str]:
    """Return a list of bot usernames (without '@') owned by this account."""
    botfather = await client.get_entity("BotFather")
    cur = await _botfather_cursor(client, botfather)
    await _botfather_send(client, botfather, "/mybots")

    def pred(m) -> bool:
        txt = (getattr(m, "raw_text", None) or "").lower()
        return bool(getattr(m, "buttons", None)) and ("choose a bot" in txt)

    msg, cur = await _botfather_wait_for_message(client, botfather, min_id=cur, timeout_s=90, pred=pred)
    usernames: List[str] = []
    for row in (msg.buttons or []):
        for b in row:
            t = (getattr(b, "text", None) or "").strip()
            if not t:
                continue
            if t.lower() in ("back", "next", "done"):
                continue
            if t.startswith("@"):
                usernames.append(t[1:])
            else:
                usernames.append(t)
    # De-dup while preserving order.
    out: List[str] = []
    seen = set()
    for u in usernames:
        if u and u not in seen:
            seen.add(u)
            out.append(u)
    return out


async def _botfather_revoke_token(client, bot_username: str) -> str:
    """Generate a new token for an existing bot via /revoke."""
    botfather = await client.get_entity("BotFather")
    cur = await _botfather_cursor(client, botfather)

    # Reset any wizard state.
    try:
        await _botfather_send(client, botfather, "/cancel")
    except Exception:
        pass

    await _botfather_send(client, botfather, "/revoke")
    _, cur = await _botfather_wait_for_text(
        client,
        botfather,
        min_id=cur,
        timeout_s=90,
        pred_text=lambda t: ("choose a bot" in t.lower() and "token" in t.lower()) or ("warning" in t.lower() and "token" in t.lower()),
    )

    if not bot_username.startswith("@"):
        bot_username = "@" + bot_username
    await _botfather_send(client, botfather, bot_username)

    txt, _ = await _botfather_wait_for_text(
        client,
        botfather,
        min_id=cur,
        timeout_s=120,
        pred_text=lambda t: TOKEN_RE.search(t) is not None,
    )
    m = TOKEN_RE.search(txt)
    if not m:
        raise RuntimeError("BotFather revoke did not return a token")
    return m.group(1)


async def _create_bot_via_botfather(client, spec: BotSpec) -> CreatedBot:
    botfather = await client.get_entity("BotFather")

    import asyncio
    import time

    from telethon.errors import FloodWaitError

    async def create_once() -> CreatedBot:
        # Telethon conversations rely on receiving updates; with Telegram Desktop-derived
        # sessions, updates can occasionally be flaky. Polling message history is slower
        # but far more reliable.

        async def send(text: str) -> None:
            while True:
                try:
                    await client.send_message(botfather, text)
                    return
                except FloodWaitError as e:
                    await asyncio.sleep(int(getattr(e, "seconds", 1)) + 1)

        async def get_new(min_id: int) -> Tuple[List[object], int]:
            msgs = await client.get_messages(botfather, min_id=min_id, limit=50)
            if not msgs:
                return ([], min_id)
            msgs_sorted = sorted(msgs, key=lambda m: int(getattr(m, "id", 0)))
            new_min = max(int(getattr(m, "id", 0)) for m in msgs_sorted)
            return (msgs_sorted, new_min)

        async def wait_for(pred, min_id: int, timeout_s: int) -> Tuple[str, int]:
            deadline = time.monotonic() + timeout_s
            cur = min_id
            while time.monotonic() < deadline:
                msgs, cur2 = await get_new(cur)
                cur = cur2
                for m in msgs:
                    if getattr(m, "out", False):
                        continue
                    txt = (getattr(m, "raw_text", None) or "").strip()
                    if not txt:
                        continue
                    lower = txt.lower()
                    if "too many attempts" in lower:
                        secs = _parse_botfather_retry_seconds(txt) or 0
                        raise BotFatherRetryAfter(secs, txt)
                    if pred(txt):
                        return (txt, cur)
                await asyncio.sleep(1.0)
            raise TimeoutError("BotFather reply timed out")

        # Start cursor at last seen message id in the BotFather dialog.
        last = await client.get_messages(botfather, limit=1)
        cursor = int(last[0].id) if last else 0

        async def start_wizard(cur: int) -> int:
            # Always reset state first: if BotFather is mid-wizard, it can misinterpret.
            await send("/cancel")
            try:
                _, cur = await wait_for(lambda t: True, cur, timeout_s=30)
            except TimeoutError:
                pass

            await send("/newbot")
            _, cur = await wait_for(
                lambda t: ("choose a name" in t.lower() and "bot" in t.lower())
                or ("how are we going to call it" in t.lower()),
                cur,
                timeout_s=240,
            )

            await send(spec.name)
            _, cur = await wait_for(
                lambda t: ("choose a username" in t.lower() and "bot" in t.lower())
                or ("username" in t.lower() and "choose" in t.lower() and "bot" in t.lower()),
                cur,
                timeout_s=240,
            )
            return cur

        cursor = await start_wizard(cursor)

        base = _normalize_username(spec.username_base)
        username = base

        for attempt in range(30):
            await send(username)
            text, cursor = await wait_for(lambda t: True, cursor, timeout_s=240)

            m = TOKEN_RE.search(text)
            if m:
                token = m.group(1)
                return CreatedBot(
                    env_var=spec.env_var,
                    name=spec.name,
                    username=username,
                    token=token,
                    source="botfather:newbot",
                )

            lower = text.lower()
            if "i can help you create and manage telegram bots" in lower:
                # Desynced; restart wizard and try again with a new username.
                cursor = await start_wizard(cursor)
                username = _normalize_username(f"{base}_{_random_suffix(4)}")
                continue
            if "username is already taken" in lower or "is already taken" in lower:
                username = _normalize_username(f"{base}_{_random_suffix(4)}")
                continue
            if "must end in" in lower and "bot" in lower:
                username = _normalize_username(username)
                continue
            if "invalid" in lower:
                username = _normalize_username(f"{base}_{_random_suffix(4)}")
                continue

            # Unknown state; try a new username once, then fail.
            if attempt < 3:
                username = _normalize_username(f"{base}_{_random_suffix(4)}")
                continue
            raise RuntimeError(f"BotFather unexpected response for {spec.env_var}: {text[:200]}")

        raise RuntimeError(f"Failed to create bot for {spec.env_var}")

    # Retry on transient timeouts (BotFather occasionally delays responses).
    last_err: Optional[BaseException] = None
    for i in range(6):
        try:
            return await create_once()
        except BotFatherRetryAfter:
            raise
        except TimeoutError as e:
            last_err = e
            await asyncio.sleep(5 + i * 10)
            continue
    raise last_err or RuntimeError(f"Failed to create bot for {spec.env_var}")


async def _invite_to_group(client, group_entity, bot_username: str) -> None:
    from telethon.errors.rpcerrorlist import UserAlreadyParticipantError
    from telethon.tl.functions.channels import InviteToChannelRequest
    from telethon.tl.functions.messages import AddChatUserRequest

    if not bot_username.startswith("@"):
        bot_username = "@" + bot_username

    user = await client.get_entity(bot_username)
    cls = group_entity.__class__.__name__

    try:
        if cls == "Channel":
            await client(InviteToChannelRequest(group_entity, [user]))
        elif cls == "Chat":
            await client(AddChatUserRequest(chat_id=int(group_entity.id), user_id=user, fwd_limit=0))
        else:
            raise RuntimeError(f"Unsupported group entity type: {cls}")
    except UserAlreadyParticipantError:
        return


async def _harvest_botfather_tokens(client, limit: int = 500) -> Dict[str, str]:
    """Return {username: token} from recent BotFather 'new bot' messages."""
    botfather = await client.get_entity("BotFather")
    msgs = await client.get_messages(botfather, limit=limit)

    user_re = re.compile(r"t\.me/([A-Za-z0-9_]+)")
    found: Dict[str, str] = {}
    for m in msgs:
        txt = (m.raw_text or "").strip()
        if not txt:
            continue
        tmatch = TOKEN_RE.search(txt)
        if not tmatch:
            continue
        token = tmatch.group(1)
        um = user_re.search(txt)
        if not um:
            continue
        username = um.group(1)
        # Keep the most recent token for that username (messages are newest-first).
        found.setdefault(username, token)
    return found


async def _find_target_group(client, title_hint: Optional[str]) -> Tuple[object, str, int]:
    dialogs = await client.get_dialogs(limit=400)

    groups: List[Tuple[object, str]] = []
    for d in dialogs:
        ent = d.entity
        cls = ent.__class__.__name__
        is_group = (cls == "Chat") or (cls == "Channel" and getattr(ent, "megagroup", False))
        if not is_group:
            continue
        groups.append((ent, (d.name or "").strip()))

    if not groups:
        raise RuntimeError("No Telegram groups found in this account.")

    if title_hint:
        needle = title_hint.lower().strip()
        matches = [(e, n) for (e, n) in groups if needle in (n or "").lower()]
    else:
        matches = groups

    if len(matches) == 1:
        ent, name = matches[0]
        chat_id = _bot_api_chat_id(ent)
        if chat_id is None:
            raise RuntimeError(f"Failed to compute Bot API chat_id for group '{name}'")
        return ent, name, chat_id

    # Ambiguous: require explicit hint.
    # Print a short, token-free list for operator selection.
    preview = []
    for ent, name in matches[:40]:
        preview.append({"name": name, "type": ent.__class__.__name__, "id": ent.id, "bot_api_chat_id": _bot_api_chat_id(ent)})
    raise RuntimeError(
        "Multiple groups matched. Re-run with --group-title to disambiguate.\n"
        + json.dumps(preview, indent=2)[:5000]
    )


def _build_bot_specs() -> List[BotSpec]:
    # Keep usernames stable if available; fall back to suffixed variants if occupied.
    return [
        BotSpec("TELEGRAM_BOT_TOKEN", "Jarvis KR8TIV", "jarviskr8tivbot"),
        BotSpec("TELEGRAM_BUY_BOT_TOKEN", "Jarvis Buy Tracker", "jarvis_buytracker_bot"),
        BotSpec("TREASURY_BOT_TOKEN", "JARVIS Treasury Bot", "jarvis_treasury_bot"),
        BotSpec("PUBLIC_BOT_TELEGRAM_TOKEN", "Jarvis Public Trading Bot", "jarvis_public_trading_bot"),
        BotSpec("X_BOT_TELEGRAM_TOKEN", "X Telegram KR8TIV Bot", "x_telegram_kr8tiv_bot"),
        BotSpec("CLAWDJARVIS_BOT_TOKEN", "ClawdJarvis", "clawdjarvis_bot"),
        BotSpec("CLAWDMATT_BOT_TOKEN", "ClawdMatt", "clawdmatt_bot"),
        BotSpec("CLAWDFRIDAY_BOT_TOKEN", "ClawdFriday", "clawdfriday_bot"),
    ]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--group-title", type=str, default=None, help="Substring to match the target private group title")
    ap.add_argument("--session-name", type=str, default="tdesktop_jarvis", help="Telethon session basename to create/use")
    ap.add_argument("--tdata", type=str, default=None, help="Override Telegram Desktop tdata path")
    ap.add_argument(
        "--mode",
        type=str,
        choices=["rotate", "full"],
        default="rotate",
        help="rotate = revoke tokens for existing bots only; full = rotate + create missing bots",
    )
    ap.add_argument(
        "--wait",
        action="store_true",
        help="If BotFather rate-limits bot creation, sleep for the specified retry-after seconds and continue.",
    )
    ap.add_argument(
        "--preserve-existing",
        action="store_true",
        help="When a token isn't rekeyed in this run, keep the existing value from local tg_bot/.env or tokens.env instead of blanking it.",
    )
    ap.add_argument(
        "--skip-env",
        action="append",
        default=[],
        help="Env var name to skip creating (use existing BotFather bot instead). Can be repeated.",
    )
    args = ap.parse_args()

    root = _repo_root()
    secrets_dir = _ensure_secrets_dir(root)

    tdata_path = Path(args.tdata) if args.tdata else _default_tdata_path()
    if not tdata_path.exists():
        raise SystemExit(f"tdata not found at: {tdata_path}")

    import asyncio

    async def run() -> int:
        client = await _telethon_client_from_tdesktop(tdata_path, args.session_name)
        await client.connect()
        try:
            me = await client.get_me()
            my_id = int(me.id)
            my_username = getattr(me, "username", None)

            group_ent, group_name, group_chat_id = await _find_target_group(client, args.group_title)

            skip_env = set()
            for item in args.skip_env or []:
                for part in (item or "").split(","):
                    part = part.strip()
                    if part:
                        skip_env.add(part)

            owned_usernames = set(await _botfather_list_bots(client))

            # Create bots
            specs = _build_bot_specs()
            created: List[CreatedBot] = []
            rotated: List[CreatedBot] = []
            pending: List[Dict[str, object]] = []
            token_by_env: Dict[str, str] = {}
            username_by_env: Dict[str, str] = {}
            existing_jarvis_env = _load_env_kv(root / "tg_bot" / ".env")
            existing_clawd_env = _load_env_kv(root / "tokens.env")

            for spec in specs:
                # Ensure only the *final* status for each env var is persisted to meta
                # (e.g. if we were rate-limited but later succeed, don't keep the stale entry).
                pending = [p for p in pending if p.get("env_var") != spec.env_var]

                base_username = _normalize_username(spec.username_base)
                if spec.env_var in skip_env:
                    pending.append({"env_var": spec.env_var, "reason": "skipped"})
                    continue
                if base_username in owned_usernames:
                    # Best path: revoke token for an existing bot (fresh token, no /newbot).
                    token = await _botfather_revoke_token(client, base_username)
                    token_by_env[spec.env_var] = token
                    username_by_env[spec.env_var] = base_username
                    rotated.append(
                        CreatedBot(spec.env_var, spec.name, base_username, token, source="botfather:revoke")
                    )
                    continue

                if args.mode == "rotate":
                    pending.append({"env_var": spec.env_var, "reason": "missing_bot_rotate_mode"})
                    continue

                # Full mode: create missing bots via /newbot (may be rate-limited).
                while True:
                    try:
                        bot = await _create_bot_via_botfather(client, spec)
                        created.append(bot)
                        token_by_env[bot.env_var] = bot.token
                        username_by_env[bot.env_var] = bot.username
                        owned_usernames.add(bot.username)
                        # Success: clear any stale pending entries for this env var.
                        pending = [p for p in pending if p.get("env_var") != spec.env_var]
                        break
                    except BotFatherRetryAfter as e:
                        pending.append({"env_var": spec.env_var, "reason": "rate_limited", "retry_after_s": e.seconds})
                        if not args.wait:
                            break
                        # Sleep the full cooldown (+ buffer) then retry.
                        import asyncio

                        await asyncio.sleep(max(0, int(e.seconds)) + 5)
                        continue

            # Invite bots to group (best effort)
            for bot in (created + rotated):
                try:
                    await _invite_to_group(client, group_ent, bot.username)
                except Exception:
                    # Don't fail rekey if one invite fails; group permissions can be fixed later.
                    pass

            # Local updates (Jarvis Telegram bot)
            def pick_token(key: str, existing: Dict[str, str]) -> str:
                v = (token_by_env.get(key) or "").strip()
                if v:
                    return v
                # If the operator explicitly skipped creating/revoking this env var, we should
                # keep whatever value is already present locally instead of blanking it.
                if key in skip_env:
                    return (existing.get(key) or "").strip()
                if args.preserve_existing:
                    return (existing.get(key) or "").strip()
                return ""

            telegram_main = pick_token("TELEGRAM_BOT_TOKEN", existing_jarvis_env)
            jarvis_env_updates = {
                "TELEGRAM_BOT_TOKEN": telegram_main,
                "TELEGRAM_BUY_BOT_TOKEN": pick_token("TELEGRAM_BUY_BOT_TOKEN", existing_jarvis_env),
                "TREASURY_BOT_TOKEN": pick_token("TREASURY_BOT_TOKEN", existing_jarvis_env),
                "TREASURY_BOT_TELEGRAM_TOKEN": pick_token("TREASURY_BOT_TOKEN", existing_jarvis_env),
                "PUBLIC_BOT_TELEGRAM_TOKEN": pick_token("PUBLIC_BOT_TELEGRAM_TOKEN", existing_jarvis_env),
                # X sync is push-only; if no dedicated X bot yet, fall back to main token.
                "X_BOT_TELEGRAM_TOKEN": pick_token("X_BOT_TELEGRAM_TOKEN", existing_jarvis_env) or telegram_main,
                "TELEGRAM_ADMIN_IDS": str(my_id),
                "TREASURY_ADMIN_IDS": str(my_id),
                "TELEGRAM_ADMIN_CHAT_ID": str(group_chat_id),
                "TELEGRAM_CHAT_ID": str(group_chat_id),
                "TELEGRAM_BUY_BOT_CHAT_ID": str(group_chat_id),
                "TELEGRAM_BROADCAST_CHAT_ID": str(group_chat_id),
            }
            _upsert_env(root / "tg_bot" / ".env", jarvis_env_updates)

            # Local updates (ClawdBots tokens)
            clawd_tokens_updates = {
                "CLAWDJARVIS_BOT_TOKEN": pick_token("CLAWDJARVIS_BOT_TOKEN", existing_clawd_env),
                "CLAWDMATT_BOT_TOKEN": pick_token("CLAWDMATT_BOT_TOKEN", existing_clawd_env),
                "CLAWDFRIDAY_BOT_TOKEN": pick_token("CLAWDFRIDAY_BOT_TOKEN", existing_clawd_env),
                "TREASURY_BOT_TOKEN": pick_token("TREASURY_BOT_TOKEN", existing_clawd_env),
                "X_BOT_TELEGRAM_TOKEN": pick_token("X_BOT_TELEGRAM_TOKEN", existing_clawd_env) or telegram_main,
            }
            _upsert_env(root / "tokens.env", clawd_tokens_updates)

            # Allowlist update
            _update_allowlist_user_id(root / "allowlist.vps.json", new_user_id=my_id, name="Matt")

            # Secret update bundles for VPS deployment
            _write_update_bundle(secrets_dir / "rekey_jarvis_updates.env", jarvis_env_updates)
            _write_update_bundle(secrets_dir / "rekey_clawdbots_updates.env", clawd_tokens_updates)
            (secrets_dir / "rekey_meta.json").write_text(
                json.dumps(
                    {
                        "me": {"id": my_id, "username": my_username},
                        "group": {"name": group_name, "chat_id": group_chat_id, "entity_type": group_ent.__class__.__name__},
                        "bots": [
                            {
                                "env_var": b.env_var,
                                "name": b.name,
                                "username": "@" + b.username,
                                "token_preview": _mask(b.token),
                                "source": b.source,
                            }
                            for b in (created + rotated)
                        ],
                        "pending": pending,
                    },
                    indent=2,
                )
                + "\n",
                encoding="utf-8",
            )

            # Copy Telethon user session into ~/.telegram_dl/session.session so existing helper scripts work.
            try:
                src = root / f"{args.session_name}.session"
                if src.exists():
                    dst_dir = Path.home() / ".telegram_dl"
                    dst_dir.mkdir(parents=True, exist_ok=True)
                    dst = dst_dir / "session.session"
                    # Backup existing
                    if dst.exists():
                        dst.replace(dst_dir / "session.session.bak")
                    dst.write_bytes(src.read_bytes())
            except Exception:
                pass

            print("OK")
            print(f"Admin user: {my_username or '(no username)'} ({my_id})")
            print(f"Target group: {group_name} (chat_id {group_chat_id})")
            print("Created bots:")
            for b in created:
                print(f"  - {b.env_var}: @{b.username} (new)")
            for b in rotated:
                print(f"  - {b.env_var}: @{b.username} (rotated)")
            if pending:
                print("Pending bots:")
                for p in pending:
                    print(f"  - {p.get('env_var')}: {p.get('reason')}")
            print(f"Updated: {root / 'tg_bot' / '.env'} (tokens/chat/admin)")
            print(f"Updated: {root / 'tokens.env'} (clawd tokens)")
            print(f"Updated: {root / 'allowlist.vps.json'} (admin id)")
            print(f"Wrote:   {secrets_dir / 'rekey_jarvis_updates.env'}")
            print(f"Wrote:   {secrets_dir / 'rekey_clawdbots_updates.env'}")
            print(f"Wrote:   {secrets_dir / 'rekey_meta.json'}")
            return 0
        finally:
            await client.disconnect()

    return asyncio.run(run())


if __name__ == "__main__":
    raise SystemExit(main())
