"""
Video to Knowledge Pipeline
Extracts audio from videos, transcribes, and converts to markdown docs.
"""

import os
import subprocess
import sys
from pathlib import Path
from datetime import datetime
import re

# Configuration
DOWNLOADS_DIR = Path(r"C:\Users\lucid\Downloads")
OUTPUT_DIR = Path(r"C:\Users\lucid\OneDrive\Desktop\Projects\Jarvis\docs\transcripts")
FFMPEG_PATH = r"C:\Users\lucid\AppData\Local\Microsoft\WinGet\Packages\Gyan.FFmpeg_Microsoft.Winget.Source_8wekyb3d8bbwe\ffmpeg-8.0.1-full_build\bin\ffmpeg.exe"

# Video files to process
VIDEO_FILES = [
    "$1.7 Billion Liquidated Last Night So I'm Building A Liquidation Bot.mov",
    "-solana copy bot that is up 5.2_ in its first week .mov",
    "Bitcoin & Eth ATH Arbitrage Bots Nfts Back A.mov",
    "Claude Code 4 Trading Removes The Need Of Manual Traders.mov",
    "This Trading Bot Is Too Good To Share On The Internet (but i do anyway).mov"
]


def sanitize_filename(name: str) -> str:
    """Convert video name to clean filename."""
    # Remove extension
    name = Path(name).stem
    # Remove special chars
    name = re.sub(r'[^\w\s-]', '', name)
    # Replace spaces with underscores
    name = re.sub(r'\s+', '_', name)
    # Lowercase
    return name.lower().strip('_')


def extract_audio(video_path: Path, audio_path: Path) -> bool:
    """Extract audio from video to WAV format."""
    print(f"  Extracting audio from: {video_path.name}")

    cmd = [
        FFMPEG_PATH,
        '-i', str(video_path),
        '-vn',  # No video
        '-acodec', 'pcm_s16le',  # WAV codec
        '-ar', '16000',  # 16kHz for whisper
        '-ac', '1',  # Mono
        '-y',  # Overwrite
        str(audio_path)
    ]

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=1800  # 30 min timeout per file
        )
        if result.returncode == 0:
            print(f"  [OK] Audio extracted: {audio_path.name}")
            return True
        else:
            print(f"  [ERROR] FFmpeg error: {result.stderr[:200]}")
            return False
    except subprocess.TimeoutExpired:
        print(f"  [ERROR] Timeout extracting audio")
        return False
    except Exception as e:
        print(f"  [ERROR] Error: {e}")
        return False


def transcribe_audio(audio_path: Path) -> str:
    """Transcribe audio using whisper."""
    print(f"  Transcribing: {audio_path.name}")

    try:
        import whisper

        # Load model (tiny is fastest, base is balanced, small/medium/large for accuracy)
        model = whisper.load_model("tiny")

        # Transcribe
        result = model.transcribe(
            str(audio_path),
            language="en",
            verbose=False
        )

        print(f"  [OK] Transcription complete")
        return result["text"]
    except Exception as e:
        print(f"  [ERROR] Transcription error: {e}")
        return ""


def create_markdown(title: str, transcript: str, video_name: str) -> str:
    """Create markdown document from transcript."""

    # Clean up title
    display_title = Path(video_name).stem.strip('-_$ ')

    md = f"""# {display_title}

**Source:** {video_name}
**Transcribed:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
**Type:** Video Tutorial/Guide

---

## Summary

*Auto-generated transcript from video. Key topics covered below.*

---

## Full Transcript

{transcript}

---

## Key Takeaways

*[To be extracted manually or via AI analysis]*

---

## Action Items

- [ ] Review transcript for actionable insights
- [ ] Extract code snippets if any
- [ ] Identify strategies/techniques to implement

---

*Generated by JARVIS Video-to-Knowledge Pipeline*
"""
    return md


def main():
    print("=" * 60)
    print("  JARVIS Video-to-Knowledge Pipeline")
    print("=" * 60)
    print()

    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    audio_dir = OUTPUT_DIR / "audio"
    audio_dir.mkdir(exist_ok=True)

    processed = []
    failed = []

    for video_name in VIDEO_FILES:
        video_path = DOWNLOADS_DIR / video_name

        if not video_path.exists():
            print(f"\n[WARN] Video not found: {video_name}")
            failed.append(video_name)
            continue

        print(f"\n{'='*60}")
        print(f"Processing: {video_name}")
        print(f"{'='*60}")

        # Generate clean filename
        clean_name = sanitize_filename(video_name)
        audio_path = audio_dir / f"{clean_name}.wav"
        md_path = OUTPUT_DIR / f"{clean_name}.md"

        # Skip if markdown already exists
        if md_path.exists():
            print(f"  [SKIP] Markdown already exists: {md_path.name}")
            processed.append(video_name)
            continue

        # Step 1: Extract audio
        if not audio_path.exists():
            if not extract_audio(video_path, audio_path):
                failed.append(video_name)
                continue
        else:
            print(f"  [SKIP] Audio already exists, skipping extraction")

        # Step 2: Transcribe
        print(f"  Starting transcription (this may take a while)...")
        transcript = transcribe_audio(audio_path)

        if not transcript:
            failed.append(video_name)
            continue

        # Step 3: Create markdown
        md_content = create_markdown(clean_name, transcript, video_name)
        md_path.write_text(md_content, encoding='utf-8')
        print(f"  [OK] Markdown created: {md_path.name}")

        processed.append(video_name)

    # Summary
    print(f"\n{'='*60}")
    print("  SUMMARY")
    print(f"{'='*60}")
    print(f"  Processed: {len(processed)}")
    print(f"  Failed:    {len(failed)}")
    print(f"  Output:    {OUTPUT_DIR}")

    if processed:
        print(f"\n  [OK] Successfully processed:")
        for v in processed:
            print(f"    - {v}")

    if failed:
        print(f"\n  [FAILED] Failed:")
        for v in failed:
            print(f"    - {v}")

    return len(failed) == 0


if __name__ == "__main__":
    success = main()

    # Ask about deleting videos
    if success:
        print(f"\n{'='*60}")
        response = input("Delete original video files? (y/n): ")
        if response.lower() == 'y':
            for video_name in VIDEO_FILES:
                video_path = DOWNLOADS_DIR / video_name
                if video_path.exists():
                    video_path.unlink()
                    print(f"  Deleted: {video_name}")
            print("  [OK] All videos deleted")
