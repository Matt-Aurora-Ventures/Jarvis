# Phase 5: Solana Integration Fixes & Performance Optimization

**Phase**: 5 of 8
**Timeline**: 1-2 weeks
**Priority**: P0 (Must-Have for V1)
**Status**: Planning
**Dependencies**: None (can run parallel)

---

## Objective

Fix Solana transaction issues and optimize for production-grade performance using industry best practices.

**Success Criteria:**
- 100% transaction success rate (no failed txs from bugs)
- <500ms transaction confirmation time (p95)
- Real-time price streaming via WebSockets
- Proper commitment level handling (confirmed/finalized)
- Transaction simulation before sending
- Dynamic priority fees implementation
- Comprehensive error handling for all RPC failures

---

## Architecture Recommendations (from Solana Best Practices)

### Current Stack Audit

**‚úì Already Using:**
- **python-telegram-bot**: Modern async Telegram framework (verified in tg_bot/bot.py)
- **Helius RPC**: Enhanced RPC provider with better performance (HELIUS_API_KEY configured)
- **bags.fm API**: Primary execution platform (BAGS_API_KEY + BAGS_PARTNER_KEY)
- **Jupiter Aggregator**: DEX routing across Solana ecosystem

**‚ùå Missing (Critical Gaps):**
1. **solana-py**: Not verified as canonical Python SDK (may be using outdated version)
2. **Streaming**: No Yellowstone gRPC / Geyser for real-time blockchain data
3. **Jito**: No low-latency transaction sending or bundle support
4. **Priority Fees**: No dynamic priority fee calculation
5. **Transaction Simulation**: May not be using `simulateTransaction` RPC before sending
6. **Commitment Levels**: Unknown if using `confirmed`/`finalized` properly
7. **WebSocket Subscriptions**: No `accountSubscribe` / `logsSubscribe` for real-time events
8. **Solders**: Not using high-performance Rust-backed primitives

### Recommended Architecture (from Solana Trading Bot Best Practices)

```
Event-Driven Flow:
Streams (WebSocket/Geyser) ‚Üí Strategy ‚Üí Execution ‚Üí Confirmation

Performance Stack:
- Low-latency RPC: ‚úì Helius (already configured)
- Streaming: ‚ùå Need Yellowstone gRPC or native WebSocket subscriptions
- Fast TX send: ‚ùå Need Jito bundles + priority fees
- Commitment: ‚ùå Need confirmed/finalized handling
```

**Target Latency Breakdown:**
- Price update detection: <50ms (WebSocket stream)
- Strategy decision: <10ms (local computation)
- Transaction build: <20ms (solana-py optimization)
- Simulation: <100ms (RPC call)
- TX send: <50ms (Jito or fast RPC)
- Confirmation wait: <400ms (confirmed) or <2s (finalized)
- **Total: <500ms for confirmed, <2.5s for finalized**

---

## Current State Assessment

### Files to Audit

1. **core/trading/instrumented_jupiter.py** - Jupiter integration
2. **bots/treasury/jupiter.py** - Treasury Jupiter client
3. **core/resilience/retry.py** - RPC retry logic
4. **tg_bot/handlers/demo/demo_trading.py** - Trade execution
5. **bots/treasury/trading.py** - Treasury trading engine

### Known Issues (from CONCERNS.md)

1. **Jupiter DEX Integration** - "Fragile area, fallback mechanisms, multiple implementations"
2. **Performance Issues** - "100+ sleep() calls causing blocking"
3. **Database queries** - "Slower queries, cannot JOIN across 28+ databases"

---

## Tasks Breakdown

### Task 1: Audit Solana SDK Usage (2-3 hours)

**Objective**: Verify we're using canonical solana-py and best practices

**Check Points**:

1. **Verify solana-py version**:
```bash
pip list | grep solana
# Expected: solana==0.34.0+ (latest stable)
# Check: solders>=0.21.0 (high-performance backend)
```

2. **Audit RPC client initialization**:
```python
# GOOD: Proper commitment level
from solana.rpc.api import Client
from solana.rpc.commitment import Confirmed, Finalized

client = Client(
    "https://mainnet.helius-rpc.com/?api-key=...",
    commitment=Confirmed,
    timeout=30
)

# BAD: No commitment level specified
client = Client("https://api.mainnet-beta.solana.com")
```

3. **Check transaction sending patterns**:
```python
# GOOD: With simulation + commitment check
from solana.rpc.types import TxOpts

# Simulate first
sim_result = await client.simulate_transaction(tx)
if sim_result.value.err:
    raise Exception(f"Simulation failed: {sim_result.value.err}")

# Send with options
result = await client.send_transaction(
    tx,
    opts=TxOpts(
        skip_preflight=False,  # Always preflight
        preflight_commitment=Confirmed,
        max_retries=3
    )
)

# Wait for confirmation
await client.confirm_transaction(
    result.value,
    commitment=Confirmed
)

# BAD: Fire and forget
result = await client.send_transaction(tx)
# No simulation, no confirmation wait!
```

4. **Verify SPL token account handling**:
```python
# GOOD: Check for associated token account, create if needed
from spl.token.instructions import get_associated_token_address

ata = get_associated_token_address(owner, mint)
account_info = await client.get_account_info(ata)

if not account_info.value:
    # Create ATA instruction
    create_ata_ix = create_associated_token_account(
        payer=payer.pubkey(),
        owner=owner,
        mint=mint
    )
    # Add to transaction
```

**Actions**:
- Read all Solana-related files listed above
- Document current SDK usage patterns
- Identify deviations from best practices
- Create upgrade plan if using outdated patterns

**Success Criteria**:
- solana-py >= 0.34.0 installed
- All RPC calls use commitment levels
- Transaction simulation used before sending
- SPL token accounts properly managed

**Risk**: MEDIUM (may require code changes)

---

### Task 2: Implement WebSocket Price Streaming (4-5 hours)

**Objective**: Replace polling with real-time WebSocket subscriptions for price updates

**Current Pattern** (polling):
```python
# BAD: Polling every 10 seconds
while True:
    price = await jupiter.get_token_price(mint)
    check_tpsl(price)
    await asyncio.sleep(10)  # Blocking, slow
```

**Target Pattern** (WebSocket streaming):
```python
# GOOD: Real-time updates via WebSocket
from solana.rpc.websocket_api import connect
from solana.rpc.commitment import Confirmed

async def stream_account_updates(account_pubkey: str):
    """Stream real-time account updates via WebSocket."""
    async with connect("wss://mainnet.helius-rpc.com/?api-key=...") as websocket:
        # Subscribe to account changes
        await websocket.account_subscribe(
            account_pubkey,
            commitment=Confirmed
        )

        # Process updates in real-time
        first_resp = await websocket.recv()
        subscription_id = first_resp[0].result

        async for message in websocket:
            # Account updated - process immediately
            account_data = message[0].result.value
            await process_account_update(account_data)

# For token price monitoring:
async def stream_token_price(mint: str):
    """Stream token price from Jupiter pool account."""
    pool_account = await get_jupiter_pool_account(mint)

    async for update in stream_account_updates(pool_account):
        new_price = parse_pool_data(update)
        await check_tpsl_triggers(mint, new_price)
```

**Implementation**:

Create `core/solana/websocket_client.py`:
```python
"""Real-time Solana data streaming via WebSockets."""
import asyncio
import logging
from typing import Callable, Dict, Any, Optional
from solana.rpc.websocket_api import connect, SolanaWsClientProtocol
from solana.rpc.commitment import Confirmed
from solana.publickey import PublicKey

logger = logging.getLogger(__name__)


class SolanaWebSocketClient:
    """Manages WebSocket subscriptions for real-time Solana data."""

    def __init__(self, ws_url: str, commitment=Confirmed):
        self.ws_url = ws_url
        self.commitment = commitment
        self._ws: Optional[SolanaWsClientProtocol] = None
        self._subscriptions: Dict[str, int] = {}  # sub_name -> subscription_id
        self._handlers: Dict[str, Callable] = {}

    async def connect(self):
        """Establish WebSocket connection."""
        self._ws = await connect(self.ws_url)
        logger.info(f"Connected to Solana WebSocket: {self.ws_url}")

    async def disconnect(self):
        """Close WebSocket connection."""
        if self._ws:
            await self._ws.close()
            logger.info("Disconnected from Solana WebSocket")

    async def subscribe_account(
        self,
        account: PublicKey,
        handler: Callable[[Dict[str, Any]], None],
        subscription_name: str = None
    ):
        """Subscribe to account updates."""
        if not self._ws:
            await self.connect()

        sub_name = subscription_name or str(account)

        # Subscribe
        await self._ws.account_subscribe(account, commitment=self.commitment)
        first_resp = await self._ws.recv()
        subscription_id = first_resp[0].result

        self._subscriptions[sub_name] = subscription_id
        self._handlers[sub_name] = handler

        logger.info(f"Subscribed to account {account}: sub_id={subscription_id}")

    async def subscribe_logs(
        self,
        mentions: list[PublicKey],
        handler: Callable[[Dict[str, Any]], None],
        subscription_name: str = "logs"
    ):
        """Subscribe to transaction logs mentioning specific accounts."""
        if not self._ws:
            await self.connect()

        # Subscribe to logs
        await self._ws.logs_subscribe(
            filter_={"mentions": [str(m) for m in mentions]},
            commitment=self.commitment
        )
        first_resp = await self._ws.recv()
        subscription_id = first_resp[0].result

        self._subscriptions[subscription_name] = subscription_id
        self._handlers[subscription_name] = handler

        logger.info(f"Subscribed to logs: sub_id={subscription_id}")

    async def listen(self):
        """Listen for WebSocket messages and dispatch to handlers."""
        if not self._ws:
            raise RuntimeError("WebSocket not connected")

        try:
            async for message in self._ws:
                # Find handler for this subscription
                # (message format: [{'subscription': sub_id, 'result': data}])
                sub_id = message[0].get("subscription")
                data = message[0].get("result")

                # Find subscription name by ID
                sub_name = next(
                    (name for name, sid in self._subscriptions.items() if sid == sub_id),
                    None
                )

                if sub_name and sub_name in self._handlers:
                    handler = self._handlers[sub_name]
                    try:
                        await handler(data)
                    except Exception as e:
                        logger.error(f"Handler error for {sub_name}: {e}", exc_info=True)

        except Exception as e:
            logger.error(f"WebSocket listen error: {e}", exc_info=True)
            raise


# Singleton
_ws_client: Optional[SolanaWebSocketClient] = None


def get_ws_client() -> SolanaWebSocketClient:
    """Get or create WebSocket client singleton."""
    global _ws_client
    if _ws_client is None:
        import os
        helius_key = os.environ.get("HELIUS_API_KEY")
        ws_url = f"wss://mainnet.helius-rpc.com/?api-key={helius_key}"
        _ws_client = SolanaWebSocketClient(ws_url)
    return _ws_client
```

**Integrate into TP/SL monitoring**:

Update `tg_bot/handlers/demo/demo_orders.py`:
```python
from core.solana.websocket_client import get_ws_client

async def start_realtime_price_monitoring(positions: List[Dict]):
    """Start WebSocket-based price monitoring for positions."""
    ws_client = get_ws_client()
    await ws_client.connect()

    for pos in positions:
        mint = PublicKey(pos["address"])
        pool_account = await get_pool_account_for_token(mint)

        async def price_update_handler(data):
            # Parse pool data to get price
            new_price = parse_pool_price(data)
            pos["current_price"] = new_price

            # Check TP/SL triggers immediately
            alerts = await _check_demo_exit_triggers(None, [pos])
            if alerts:
                await process_alerts(alerts)

        await ws_client.subscribe_account(
            pool_account,
            price_update_handler,
            subscription_name=f"price_{mint}"
        )

    # Listen forever
    await ws_client.listen()
```

**Success Criteria**:
- WebSocket client implemented and tested
- Price updates received in <50ms
- TP/SL triggers detected in <100ms total latency
- No polling delays

**Risk**: MEDIUM (new component, needs testing)

---

### Task 3: Implement Dynamic Priority Fees (3-4 hours)

**Objective**: Calculate and set dynamic priority fees for faster transaction confirmation

**Background**: Solana uses priority fees to get transactions included faster. Without them, transactions may be dropped during high congestion.

**Implementation**:

Create `core/solana/priority_fees.py`:
```python
"""Dynamic priority fee calculation for Solana transactions."""
import logging
from typing import Optional
from solana.rpc.api import Client
from solana.rpc.types import TxOpts

logger = logging.getLogger(__name__)


async def get_recent_priority_fees(
    client: Client,
    lookback_slots: int = 150
) -> list[int]:
    """Get recent priority fees from the network."""
    # Use getRecentPrioritizationFees RPC method
    result = await client.get_recent_prioritization_fees()

    if not result.value:
        return []

    # Extract fees from last N slots
    fees = [fee.prioritization_fee for fee in result.value[-lookback_slots:]]
    return fees


def calculate_priority_fee(
    recent_fees: list[int],
    percentile: float = 0.75,  # 75th percentile for balance
    min_fee: int = 1000,        # Minimum 1000 microlamports
    max_fee: int = 100000       # Maximum 100000 microlamports
) -> int:
    """Calculate recommended priority fee based on recent network activity."""
    if not recent_fees:
        return min_fee

    # Sort and get percentile
    sorted_fees = sorted(recent_fees)
    index = int(len(sorted_fees) * percentile)
    fee = sorted_fees[min(index, len(sorted_fees) - 1)]

    # Clamp to min/max
    fee = max(min_fee, min(fee, max_fee))

    logger.info(f"Calculated priority fee: {fee} microlamports ({percentile*100}th percentile)")
    return fee


async def get_recommended_priority_fee(
    client: Client,
    urgency: str = "normal"
) -> int:
    """
    Get recommended priority fee based on urgency level.

    Args:
        client: Solana RPC client
        urgency: "low" (cheap, slow), "normal" (balanced), "high" (fast, expensive)

    Returns:
        Priority fee in microlamports
    """
    recent_fees = await get_recent_priority_fees(client)

    percentiles = {
        "low": 0.25,    # 25th percentile - cheap
        "normal": 0.75,  # 75th percentile - balanced
        "high": 0.95     # 95th percentile - fast
    }

    percentile = percentiles.get(urgency, 0.75)
    return calculate_priority_fee(recent_fees, percentile=percentile)


def add_priority_fee_to_transaction(
    transaction,
    priority_fee: int
) -> None:
    """Add compute budget + priority fee instructions to transaction."""
    from solana.transaction import Transaction
    from spl.memo.instructions import MemoParams, create_memo

    # In production, use actual compute budget instructions:
    # from solana.compute_budget import set_compute_unit_limit, set_compute_unit_price
    #
    # transaction.add(set_compute_unit_limit(200_000))  # Set compute limit
    # transaction.add(set_compute_unit_price(priority_fee))  # Set priority fee

    # For now, add as memo (replace with actual compute budget instructions)
    logger.info(f"Adding priority fee: {priority_fee} microlamports")
    # TODO: Replace with actual compute budget program instructions
```

**Usage in trade execution**:

Update `tg_bot/handlers/demo/demo_trading.py`:
```python
from core.solana.priority_fees import get_recommended_priority_fee, add_priority_fee_to_transaction

async def execute_buy_with_tpsl(...):
    # ... build transaction ...

    # Add dynamic priority fee
    urgency = "high" if amount_sol > 1.0 else "normal"  # Large trades = urgent
    priority_fee = await get_recommended_priority_fee(client, urgency=urgency)
    add_priority_fee_to_transaction(tx, priority_fee)

    # Send transaction
    result = await client.send_transaction(tx, opts=TxOpts(...))
```

**Success Criteria**:
- Priority fees calculated dynamically
- Transactions confirm faster (target <500ms for confirmed)
- No stuck/dropped transactions

**Risk**: LOW (non-breaking addition)

---

### Task 4: Add Transaction Simulation (2 hours)

**Objective**: Simulate all transactions before sending to catch errors early

**Implementation**:

Create `core/solana/transaction_sim.py`:
```python
"""Transaction simulation utilities."""
import logging
from typing import Dict, Any
from solana.rpc.api import Client
from solana.transaction import Transaction
from solana.rpc.commitment import Processed

logger = logging.getLogger(__name__)


class SimulationError(Exception):
    """Raised when transaction simulation fails."""
    pass


async def simulate_transaction(
    client: Client,
    transaction: Transaction,
    signers: list = None
) -> Dict[str, Any]:
    """
    Simulate transaction before sending.

    Args:
        client: Solana RPC client
        transaction: Transaction to simulate
        signers: Optional signers (if not already signed)

    Returns:
        Simulation result with logs and units consumed

    Raises:
        SimulationError if simulation fails
    """
    # Sign if signers provided
    if signers:
        transaction.sign(*signers)

    # Simulate
    result = await client.simulate_transaction(
        transaction,
        commitment=Processed  # Use Processed for simulation
    )

    if result.value.err:
        error = result.value.err
        logs = result.value.logs or []

        logger.error(
            f"Transaction simulation failed:\n"
            f"Error: {error}\n"
            f"Logs:\n" + "\n".join(logs)
        )

        raise SimulationError(
            f"Simulation failed: {error}\n"
            f"Logs: {' '.join(logs)}"
        )

    # Log success
    units_consumed = result.value.units_consumed or 0
    logger.info(
        f"Simulation successful: {units_consumed} compute units consumed"
    )

    return {
        "success": True,
        "units_consumed": units_consumed,
        "logs": result.value.logs,
        "accounts": result.value.accounts
    }


async def simulate_and_send(
    client: Client,
    transaction: Transaction,
    signers: list,
    opts: Any = None
) -> Dict[str, Any]:
    """
    Simulate transaction, then send if simulation passes.

    Returns:
        Transaction signature and confirmation info
    """
    # Simulate first
    sim_result = await simulate_transaction(client, transaction, signers)

    # If simulation passed, send for real
    result = await client.send_transaction(transaction, *signers, opts=opts)

    return {
        "signature": result.value,
        "simulation": sim_result
    }
```

**Usage**:
```python
from core.solana.transaction_sim import simulate_and_send

try:
    result = await simulate_and_send(
        client,
        transaction,
        signers=[wallet],
        opts=TxOpts(skip_preflight=False)
    )
    logger.info(f"Transaction sent: {result['signature']}")
except SimulationError as e:
    logger.error(f"Transaction would fail: {e}")
    # Don't send - return error to user
```

**Success Criteria**:
- 100% of transactions simulated before sending
- Failed simulations caught before wasting fees
- Clear error messages from simulation logs

**Risk**: LOW (safety improvement)

---

### Task 5: Implement Proper Commitment Level Handling (2-3 hours)

**Objective**: Use correct commitment levels (processed/confirmed/finalized) for different operations

**Commitment Levels Explained**:
- **Processed**: Transaction included in a block (may be rolled back)
- **Confirmed**: Transaction has 66% cluster confirmation (safe for most uses)
- **Finalized**: Transaction is final (32 blocks later, guaranteed)

**Guidelines**:
- **Querying data**: Use `Confirmed` (balance, account info)
- **Sending transactions**: Wait for `Confirmed` (fast, safe)
- **Critical operations**: Wait for `Finalized` (large trades, permanent records)

**Implementation**:

Create `core/solana/commitment.py`:
```python
"""Commitment level utilities and best practices."""
from solana.rpc.commitment import Commitment, Processed, Confirmed, Finalized
from typing import Literal

CommitmentLevel = Literal["processed", "confirmed", "finalized"]


def get_commitment_for_operation(operation: str) -> Commitment:
    """
    Get recommended commitment level for an operation.

    Args:
        operation: "query", "send", "critical"

    Returns:
        Commitment level enum
    """
    levels = {
        "query": Confirmed,      # Balance checks, account reads
        "send": Confirmed,        # Most transactions
        "critical": Finalized,    # Large trades, permanent state
        "simulation": Processed   # Transaction simulation
    }
    return levels.get(operation, Confirmed)


async def wait_for_confirmation(
    client,
    signature: str,
    commitment: Commitment = Confirmed,
    timeout: float = 30.0
) -> bool:
    """
    Wait for transaction confirmation at specified level.

    Args:
        client: Solana RPC client
        signature: Transaction signature to wait for
        commitment: Commitment level to wait for
        timeout: Max wait time in seconds

    Returns:
        True if confirmed, False if timeout

    Raises:
        Exception if transaction failed
    """
    import asyncio

    start_time = asyncio.get_event_loop().time()

    while True:
        # Check elapsed time
        if asyncio.get_event_loop().time() - start_time > timeout:
            return False

        # Get signature status
        result = await client.get_signature_statuses([signature])

        if not result.value or not result.value[0]:
            # Not found yet
            await asyncio.sleep(0.5)
            continue

        status = result.value[0]

        # Check for error
        if status.err:
            raise Exception(f"Transaction failed: {status.err}")

        # Check commitment level
        if commitment == Confirmed and status.confirmation_status in ["confirmed", "finalized"]:
            return True
        elif commitment == Finalized and status.confirmation_status == "finalized":
            return True

        await asyncio.sleep(0.5)
```

**Usage in trades**:
```python
from core.solana.commitment import get_commitment_for_operation, wait_for_confirmation

# Send transaction
result = await client.send_transaction(tx, opts=TxOpts(...))
signature = result.value

# Wait for appropriate commitment
if amount_sol > 10.0:
    # Large trade - wait for finalized
    commitment = get_commitment_for_operation("critical")
else:
    # Normal trade - wait for confirmed
    commitment = get_commitment_for_operation("send")

confirmed = await wait_for_confirmation(
    client,
    signature,
    commitment=commitment,
    timeout=60.0
)

if not confirmed:
    raise Exception("Transaction confirmation timeout")

logger.info(f"Transaction confirmed at {commitment} level: {signature}")
```

**Success Criteria**:
- All operations use appropriate commitment levels
- Confirmation wait logic standardized
- No premature assumes of finality

**Risk**: LOW (correctness improvement)

---

### Task 6: Error Handling & Retry Logic (3-4 hours)

**Objective**: Robust error handling for all Solana RPC failure modes

**Common Errors**:
1. **RPC Timeout**: Request took too long
2. **Rate Limit**: Too many requests
3. **Insufficient Funds**: Not enough SOL for transaction
4. **Account Not Found**: Token account doesn't exist
5. **Blockhash Expired**: Transaction too old
6. **Simulation Failed**: Transaction would fail on-chain

**Implementation**:

Enhance `core/resilience/retry.py`:
```python
"""Enhanced retry logic for Solana RPC operations."""
import asyncio
import logging
from typing import Callable, Any, Type
from functools import wraps

logger = logging.getLogger(__name__)


class SolanaRPCError(Exception):
    """Base for Solana RPC errors."""
    pass


class RateLimitError(SolanaRPCError):
    """Rate limit exceeded."""
    pass


class BlockhashExpiredError(SolanaRPCError):
    """Transaction blockhash expired."""
    pass


class InsufficientFundsError(SolanaRPCError):
    """Insufficient SOL for transaction."""
    pass


async def retry_rpc_call(
    func: Callable,
    *args,
    max_retries: int = 3,
    backoff_base: float = 1.0,
    exceptions: tuple[Type[Exception]] = (Exception,),
    **kwargs
) -> Any:
    """
    Retry an RPC call with exponential backoff.

    Args:
        func: Async function to call
        max_retries: Maximum retry attempts
        backoff_base: Base delay in seconds (exponential)
        exceptions: Exception types to catch and retry
        *args, **kwargs: Passed to func

    Returns:
        Result from func

    Raises:
        Last exception if all retries exhausted
    """
    last_exception = None

    for attempt in range(max_retries + 1):
        try:
            return await func(*args, **kwargs)

        except exceptions as e:
            last_exception = e

            # Don't retry on final attempt
            if attempt == max_retries:
                break

            # Calculate backoff
            delay = backoff_base * (2 ** attempt)

            # Special handling for rate limits
            if "429" in str(e) or "rate limit" in str(e).lower():
                delay = min(delay * 2, 30.0)  # Longer wait for rate limits
                logger.warning(f"Rate limit hit, waiting {delay}s before retry {attempt + 1}/{max_retries}")

            else:
                logger.warning(f"RPC call failed: {e}, retrying in {delay}s ({attempt + 1}/{max_retries})")

            await asyncio.sleep(delay)

    # All retries exhausted
    raise last_exception


def with_rpc_retry(max_retries: int = 3, backoff_base: float = 1.0):
    """Decorator to add retry logic to async functions."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            return await retry_rpc_call(
                func,
                *args,
                max_retries=max_retries,
                backoff_base=backoff_base,
                **kwargs
            )
        return wrapper
    return decorator


# Usage example
@with_rpc_retry(max_retries=5, backoff_base=0.5)
async def get_token_price_with_retry(mint: str) -> float:
    """Get token price with automatic retry on failure."""
    return await jupiter.get_token_price(mint)
```

**User-Friendly Error Messages**:

Add to `core/solana/errors.py`:
```python
"""User-friendly error messages for Solana failures."""


def format_solana_error(error: Exception) -> str:
    """Convert technical Solana error to user-friendly message."""
    error_str = str(error).lower()

    if "insufficient funds" in error_str:
        return (
            "‚ùå Insufficient SOL for transaction.\n"
            "You need SOL to pay for transaction fees (~0.00005 SOL per transaction).\n"
            "üí° Add SOL to your wallet or reduce trade size."
        )

    elif "account not found" in error_str or "invalid account" in error_str:
        return (
            "‚ùå Token account not found.\n"
            "This token account needs to be created first.\n"
            "üí° We'll create it automatically (costs ~0.002 SOL)."
        )

    elif "blockhash" in error_str and "expired" in error_str:
        return (
            "‚ùå Transaction expired (network congestion).\n"
            "üí° Retrying with fresh blockhash..."
        )

    elif "429" in error_str or "rate limit" in error_str:
        return (
            "‚è±Ô∏è Too many requests to Solana network.\n"
            "üí° Waiting a moment before retrying..."
        )

    elif "simulation failed" in error_str:
        return (
            "‚ùå Transaction would fail (detected via simulation).\n"
            "Common causes: Slippage too low, insufficient liquidity, or token restrictions.\n"
            "üí° Try: Increase slippage to 2-5% or check token on Solscan."
        )

    else:
        return f"‚ùå Solana error: {error}\nüí° Check logs for details."
```

**Success Criteria**:
- All RPC calls have retry logic
- User-friendly error messages
- No crashes from RPC failures
- Rate limits handled gracefully

**Risk**: LOW (robustness improvement)

---

### Task 7: Integration Testing (4-5 hours)

**Objective**: Test all Solana improvements end-to-end

**Test Scenarios**:

1. **Normal Trade Flow**:
   - Get recent priority fees
   - Build transaction with priority fee
   - Simulate transaction
   - Send with confirmed commitment
   - Wait for confirmation
   - Verify success

2. **Error Handling**:
   - Insufficient funds ‚Üí User-friendly message
   - Blockhash expired ‚Üí Auto-retry with fresh blockhash
   - Simulation failure ‚Üí Don't send, show clear error

3. **WebSocket Streaming**:
   - Subscribe to token price updates
   - Verify <50ms latency from on-chain update
   - Test reconnection on disconnect

4. **Priority Fees**:
   - Measure confirmation time with/without priority fees
   - Verify faster confirmation with fees

**Test Script**: `scripts/test_solana_improvements.py`

```python
"""Test Solana integration improvements."""
import asyncio
from core.solana.websocket_client import get_ws_client
from core.solana.priority_fees import get_recommended_priority_fee
from core.solana.transaction_sim import simulate_and_send
from core.solana.commitment import wait_for_confirmation, Confirmed

async def test_priority_fees():
    """Test dynamic priority fee calculation."""
    print("\n=== Test 1: Priority Fees ===")
    from solana.rpc.api import Client
    client = Client("https://mainnet.helius-rpc.com/?api-key=...")

    for urgency in ["low", "normal", "high"]:
        fee = await get_recommended_priority_fee(client, urgency=urgency)
        print(f"  {urgency}: {fee} microlamports")

async def test_websocket_streaming():
    """Test WebSocket price streaming."""
    print("\n=== Test 2: WebSocket Streaming ===")
    ws_client = get_ws_client()
    await ws_client.connect()

    # Subscribe to a known token account
    from solana.publickey import PublicKey
    test_account = PublicKey("...")  # Jupiter pool or token account

    update_count = 0
    async def handler(data):
        nonlocal update_count
        update_count += 1
        print(f"  Update {update_count} received")

    await ws_client.subscribe_account(test_account, handler)

    # Listen for 10 seconds
    try:
        await asyncio.wait_for(ws_client.listen(), timeout=10.0)
    except asyncio.TimeoutError:
        pass

    print(f"  Total updates: {update_count}")
    await ws_client.disconnect()

async def test_transaction_simulation():
    """Test transaction simulation."""
    print("\n=== Test 3: Transaction Simulation ===")
    # Create a simple transfer transaction
    # Simulate it
    # Verify simulation passes
    print("  (Implementation depends on test wallet setup)")

async def main():
    await test_priority_fees()
    await test_websocket_streaming()
    await test_transaction_simulation()
    print("\n‚úÖ All tests passed!")

if __name__ == "__main__":
    asyncio.run(main())
```

**Success Criteria**:
- All 4 test scenarios pass
- WebSocket latency <50ms
- Priority fees reduce confirmation time
- Error messages are user-friendly

**Risk**: MEDIUM (integration complexity)

---

## Phase Completion Checklist

- [ ] Task 1: solana-py audit complete, best practices documented
- [ ] Task 2: WebSocket streaming implemented and tested
- [ ] Task 3: Dynamic priority fees working
- [ ] Task 4: Transaction simulation on all sends
- [ ] Task 5: Commitment levels correct everywhere
- [ ] Task 6: Error handling comprehensive
- [ ] Task 7: Integration tests passing

**Phase Exit Criteria**:
- Transaction success rate >99%
- Confirmation time <500ms (p95)
- WebSocket streaming operational
- Priority fees implemented
- All error cases handled gracefully
- Comprehensive test coverage

---

## Risks & Mitigation

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| WebSocket connection drops | Medium | Medium | Auto-reconnect logic |
| Priority fees too expensive | Low | Low | Configurable max fee |
| Helius RPC downtime | Low | High | Multiple RPC fallbacks |
| solana-py API changes | Low | Medium | Pin versions, test upgrades |
| Commitment wait timeout | Medium | Medium | Clear timeout messages |

---

## Timeline Estimate

**Optimistic**: 1 week (40 hours)
**Realistic**: 1.5 weeks (60 hours)
**Pessimistic**: 2 weeks (80 hours) if major architectural changes needed

**Critical Path**: Task 1 (audit) ‚Üí Tasks 2-6 (parallel) ‚Üí Task 7 (integration tests)

---

## Success Metrics

**Performance**:
- Transaction confirmation: <500ms (p95), <2s (p99)
- WebSocket latency: <50ms for price updates
- RPC success rate: >99.9%

**Reliability**:
- Zero dropped transactions from bugs
- 100% error cases handled
- All transactions simulated before sending

**User Experience**:
- Clear, actionable error messages
- Fast TP/SL trigger detection (<100ms)
- No stuck transactions

---

**Document Version**: 1.0
**Created**: 2026-01-24
**Author**: Claude Sonnet 4.5 (Ralph Wiggum Loop)
**Audited Against**: Solana & Telegram Best Practices Document
**Next Review**: After Task 1 completion
