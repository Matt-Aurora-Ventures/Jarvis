---
phase: 02-open-claw-and-jupiter-perps-repair
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified: [bots/jupiter_perps/client.py, bots/jupiter_perps/runner.py, bots/jupiter_perps/state.py]
autonomous: true
requirements: [jupiter-perps-repair]

must_haves:
  truths:
    - "Jupiter perps bot runner successfully instantiates the Open Claw SDK."
    - "Bot passes `OpenClawSDK` outputs to Jupiter API formatting via the `client.py` wrapper."
    - "Solana wallet states and positions are tracked to manage the bot's risk loop."
  artifacts:
    - path: "bots/jupiter_perps/runner.py"
      provides: "The automated active execution loop linking logic to chain."
    - path: "bots/jupiter_perps/client.py"
      provides: "Jupiter specific execution abstraction"
  key_links:
    - from: "bots/jupiter_perps/runner.py"
      to: "core/open_claw/sdk.py"
      via: "Runner uses SDK to evaluate market before executing changes on the client"
---

<objective>
Refactor and repair the Jupiter perpetuals runner by integrating it heavily with the new `OpenClawSDK` and implementing resilient API clients.

Purpose: The jupiter bot is non-functional and currently blends algorithmic calculation closely with the execution. This plan implements the separation, making it just a dumb terminal acting on the instructions of the `Open Claw` brain while handling RPC errors appropriately.
Output: A repaired, executable bot inside `bots/jupiter_perps/`.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-open-claw-and-jupiter-perps-repair/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Jupiter Client Abstraction</name>
  <files>bots/jupiter_perps/client.py, bots/jupiter_perps/state.py</files>
  <action>
    Create a robust, async wrapper around the Jupiter v6 Perpetuals REST endpoints (or a mock wrapper that structures the `solders/solana.rpc` connection intent).
    Implement error handling specifically for Blockhash timeouts, RPC unresponsiveness, and JSON parsing errors for API endpoints.
    In `state.py`, construct simple dataclasses for maintaining local position P/L so the bot isn't fully reliant on slow chains reads constantly.
  </action>
  <verify>Test basic compilation and run an integrated script verifying an HTTP get to `quote-api.jup.ag` works successfully.</verify>
  <done>Client abstractions are safe and have defined retry limits.</done>
</task>

<task type="auto">
  <name>Task 2: Implement the Bot Runner Loop</name>
  <files>bots/jupiter_perps/runner.py</files>
  <action>
    Author the async event loop `run_bot()`.
    At the core of the loop, it should:
      1) Fetch external signals mock.
      2) Call `OpenClawSDK.evaluate_market_opportunity()`.
      3) Depending on the response containing `confidence > threshold`, invoke `client.py`'s execute logic to open/close/resize positions.
  </action>
  <verify>Run the bot module directly causing it to do exactly 1 generic simulation tick logging its intended flow through the stack and then returning.</verify>
  <done>The async `runner.py` ties everything together correctly, bridging the agnostic `Open Claw` to the concrete `Jupiter perps client`.</done>
</task>

</tasks>

<verification>
- [ ] No syntax errors in `bots/jupiter_perps`.
- [ ] A mock execution of the loop successfully logs `"Evaluating... -> Found signal... -> Executing Jupiter Client..."`.
- [ ] The runner strictly imports `core.open_claw.sdk` avoiding re-implementing logic.
</verification>

<success_criteria>
- The Jupiter perpetuals logic is resurrected but entirely abstracted out of the decision making process.
- The separation of concerns between Execution (`bots/`) and Intelligence (`core/`) is rigidly established.
</success_criteria>

<output>
After completion, create `.planning/phases/02-open-claw-and-jupiter-perps-repair/02-02-SUMMARY.md`
</output>
