# Phase 6: Security Audit & Vulnerability Fixes

**Phase**: 6 of 8
**Timeline**: 1 week
**Priority**: P0 (Must-Have for V1)
**Status**: Planning
**Dependencies**: Phase 1-5 (fixes must be secure)

---

## Objective

Eliminate all security vulnerabilities before V1 public launch.

**Success Criteria:**
- Zero critical/high vulnerabilities remaining
- API keys properly secured (no hardcoding)
- Input validation on all entry points
- Rate limiting on all public endpoints
- Admin authentication bypass fixed (already done per CONCERNS.md)
- Wallet private keys never exposed
- SQL injection impossible (parameterized queries)

---

## Known Issues (from CONCERNS.md)

### ✅ Fixed:
1. Admin Bypass (trading.py:1295-1311) - FIXED
2. Secret Exposure in repr() - FIXED
3. OAuth Token Persistence - FIXED
4. Input Validation - FIXED

### ❌ Remaining:
1. Wallet password from env var (demo.py:159)
2. API Key Proliferation (233 files with HTTP clients, 50+ APIs)
3. Rate limiting not verified across all endpoints
4. No centralized secret management

---

## Tasks Breakdown

### Task 1: Centralized Secret Management (3-4 hours)

**Create**: `core/secrets/vault.py`

```python
"""Centralized secret management."""
import os
from typing import Optional
from dataclasses import dataclass

@dataclass
class SecretConfig:
    """Secret configuration."""
    name: str
    env_var: str
    required: bool = True
    masked_value: Optional[str] = None

class SecretVault:
    """Secure secret storage."""

    SECRETS = [
        SecretConfig("anthropic_api_key", "ANTHROPIC_API_KEY"),
        SecretConfig("bags_api_key", "BAGS_API_KEY"),
        SecretConfig("bags_partner_key", "BAGS_PARTNER_KEY"),
        SecretConfig("helius_api_key", "HELIUS_API_KEY"),
        SecretConfig("telegram_bot_token", "TELEGRAM_BOT_TOKEN"),
        # ... all 50+ API keys
    ]

    def __init__(self):
        self._secrets = {}
        self._load_secrets()

    def _load_secrets(self):
        """Load secrets from environment."""
        for secret in self.SECRETS:
            value = os.environ.get(secret.env_var)
            if not value and secret.required:
                raise ValueError(f"Required secret missing: {secret.env_var}")
            self._secrets[secret.name] = value

    def get(self, name: str) -> Optional[str]:
        """Get secret by name."""
        return self._secrets.get(name)

    def __repr__(self) -> str:
        """Safe repr - never expose secrets."""
        count = len([v for v in self._secrets.values() if v])
        return f"<SecretVault: {count} secrets loaded>"

# Singleton
_vault = None

def get_vault() -> SecretVault:
    global _vault
    if not _vault:
        _vault = SecretVault()
    return _vault
```

**Success Criteria:**
- All API keys accessed via vault
- No hardcoded secrets in code
- Safe repr() on all secret-containing objects

**Risk**: LOW

---

### Task 2: Input Validation Audit (2-3 hours)

**Entry Points to Audit:**
1. Telegram message handlers
2. FastAPI endpoints
3. Callback query handlers
4. WebSocket messages

**Validation Rules:**
```python
"""Input validation utilities."""
from typing import Any

def validate_token_address(address: str) -> str:
    """Validate Solana token address."""
    if not address or len(address) not in [32, 44]:
        raise ValueError("Invalid token address")
    # Check base58 encoding
    return address

def validate_amount(amount: float, min_val: float = 0.0, max_val: float = 1000.0) -> float:
    """Validate trade amount."""
    if amount <= min_val or amount > max_val:
        raise ValueError(f"Amount must be between {min_val} and {max_val}")
    return amount

def validate_percentage(pct: float, min_val: float = 0.0, max_val: float = 500.0) -> float:
    """Validate percentage (TP/SL)."""
    if pct < min_val or pct > max_val:
        raise ValueError(f"Percentage must be between {min_val}% and {max_val}%")
    return pct
```

**Success Criteria:**
- All user inputs validated
- Clear error messages on invalid input
- No crashes from malformed data

**Risk**: LOW

---

### Task 3: Rate Limiting Verification (2 hours)

**Check All Public Endpoints:**
- `/api/metrics/bags`
- `/api/treasury/bags/*`
- `/api/trades`
- WebSocket connections

**Implementation:**
```python
"""Rate limiting middleware."""
from fastapi import Request, HTTPException
from collections import defaultdict
import time

class RateLimiter:
    def __init__(self, requests_per_minute: int = 60):
        self.limit = requests_per_minute
        self.requests = defaultdict(list)

    async def check_rate_limit(self, request: Request):
        """Check if request is rate limited."""
        client_ip = request.client.host
        now = time.time()

        # Clean old requests
        self.requests[client_ip] = [
            ts for ts in self.requests[client_ip]
            if now - ts < 60
        ]

        if len(self.requests[client_ip]) >= self.limit:
            raise HTTPException(429, "Rate limit exceeded")

        self.requests[client_ip].append(now)
```

**Success Criteria:**
- Rate limiting on all public APIs
- 429 errors returned properly
- No abuse possible

**Risk**: LOW

---

### Task 4: Private Key Security Audit (1-2 hours)

**Check:**
1. No private keys in .env (use encrypted keystore)
2. Wallet passwords not logged
3. Private keys never sent over network
4. Mnemonic phrases properly secured

**Action Items:**
- Remove wallet password from demo.py:159
- Add encrypted wallet storage
- Audit all logging for sensitive data

**Success Criteria:**
- No private keys in environment variables
- Keys stored encrypted only
- Zero chance of key exposure

**Risk**: CRITICAL

---

### Task 5: SQL Injection Prevention (1 hour)

**Audit all database queries:**
```python
# BAD
cursor.execute(f"SELECT * FROM trades WHERE user_id = {user_id}")

# GOOD
cursor.execute("SELECT * FROM trades WHERE user_id = ?", (user_id,))
```

**Success Criteria:**
- 100% parameterized queries
- No string interpolation in SQL

**Risk**: MEDIUM

---

### Task 6: Security Testing (2-3 hours)

**Test Cases:**
1. SQL injection attempts
2. XSS in Telegram messages
3. Admin bypass attempts
4. Rate limit bypass
5. Private key exposure attempts

**Success Criteria:**
- All attack vectors tested
- No vulnerabilities found
- Automated security tests

**Risk**: LOW

---

## Phase Exit Criteria

- [ ] Zero critical vulnerabilities
- [ ] All secrets centralized
- [ ] Input validation complete
- [ ] Rate limiting verified
- [ ] Private keys secured
- [ ] Security tests passing

---

**Timeline**: 1 week (40 hours)
**Risk Level**: CRITICAL (security must be perfect)

**Document Version**: 1.0
**Created**: 2026-01-24
