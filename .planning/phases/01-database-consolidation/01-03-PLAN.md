---
phase: 01-database-consolidation
plan: 03
type: execute
wave: 2
depends_on: [01-02]
files_modified:
  - core/llm/cost_tracker.py
  - core/database/__init__.py
  - bots/treasury/trading.py
  - tg_bot/handlers/demo.py
  - core/monitoring/metrics_collector.py
  - core/state_backup/state_backup.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Production code imports from core.database unified layer"
    - "No hardcoded database paths in production code"
    - "All database access goes through connection pool"
    - "Legacy get_legacy_db() function removed"
  artifacts:
    - path: "core/database/__init__.py"
      provides: "Unified database layer without legacy support"
      not_contains: "get_legacy_db"
    - path: "core/llm/cost_tracker.py"
      provides: "Uses unified layer for LLM costs"
      contains: "from core.database import get_analytics_db"
    - path: "bots/treasury/trading.py"
      provides: "Uses unified layer for trades/positions"
      contains: "from core.database import get_core_db"
  key_links:
    - from: "core/llm/cost_tracker.py"
      to: "core.database.get_analytics_db()"
      via: "import and function call"
      pattern: "get_analytics_db\\(\\)"
    - from: "bots/treasury/trading.py"
      to: "core.database.get_core_db()"
      via: "import and function call"
      pattern: "get_core_db\\(\\)"
---

<objective>
Update production code to use the unified database layer, eliminating hardcoded legacy database paths.

Purpose: Verification found only 3 files (1% adoption) use the unified layer. 11+ files in core/ still have hardcoded paths. This plan closes that gap by migrating all production code.

Output: All production code uses core.database API, no direct sqlite3 imports with hardcoded paths.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-consolidation/01-VERIFICATION.md
@.planning/phases/01-database-consolidation/01-01-SUMMARY.md
@.planning/phases/01-database-consolidation/01-02-SUMMARY.md
@core/database/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Find all hardcoded database paths</name>
  <files>.planning/phases/01-database-consolidation/01-03-DATABASE-PATHS-AUDIT.md</files>
  <action>
Search the codebase for files with hardcoded database paths that need updating:

1. Find direct sqlite3 imports with database path patterns:
   ```bash
   cd C:\Users\lucid\OneDrive\Desktop\Projects\Jarvis
   grep -r "sqlite3.connect.*data/" --include="*.py" core/ bots/ tg_bot/ > /tmp/db_paths.txt
   ```

2. Find hardcoded database filenames:
   ```bash
   grep -r "jarvis\.db\|llm_costs\.db\|metrics\.db\|rate_limiter\.db\|telegram_memory\.db" --include="*.py" core/ bots/ tg_bot/ >> /tmp/db_paths.txt
   ```

3. Find files that import sqlite3 directly (potential candidates):
   ```bash
   grep -r "^import sqlite3\|^from sqlite3 import" --include="*.py" core/ bots/ tg_bot/ >> /tmp/db_paths.txt
   ```

4. Categorize findings:
   - **P0 (Critical)**: Files in core/ that must be updated
   - **P1 (High)**: Files in bots/ that handle trades/positions/memory
   - **P2 (Medium)**: Files in tg_bot/ that may use databases
   - **Skip**: Test files, migration scripts, backup utilities

5. Create audit report with:
   - File path
   - Current database access pattern
   - Target replacement (get_core_db/get_analytics_db/get_cache_db)
   - Estimated complexity (simple/medium/complex)

Save to: .planning/phases/01-database-consolidation/01-03-DATABASE-PATHS-AUDIT.md

Gap items addressed:
- "Update all 288+ DB import files to use unified layer"
- "Remove hardcoded legacy paths from production code"
  </action>
  <verify>test -f .planning/phases/01-database-consolidation/01-03-DATABASE-PATHS-AUDIT.md</verify>
  <done>Audit report exists with categorized list of files needing updates</done>
</task>

<task type="auto">
  <name>Task 2: Update P0 core/ files to use unified layer</name>
  <files>core/llm/cost_tracker.py, core/monitoring/metrics_collector.py, core/state_backup/state_backup.py, core/database/__init__.py</files>
  <action>
Update the high-priority core/ files identified in the audit:

**For each file in P0 category:**

1. **core/llm/cost_tracker.py** (verified issue from 01-VERIFICATION.md line 38):
   - Remove: `import sqlite3` and `sqlite3.connect("data/llm_costs.db")`
   - Add: `from core.database import get_analytics_db`
   - Replace: All database operations use `conn = get_analytics_db()`
   - Keep business logic identical

2. **core/monitoring/metrics_collector.py** (if uses metrics.db directly):
   - Remove: Hardcoded path to metrics.db
   - Add: `from core.database import get_analytics_db`
   - Update: All metric writes go through unified layer

3. **core/state_backup/state_backup.py** (if uses multiple DBs):
   - Update backup logic to reference 3 consolidated databases
   - Remove references to 24 legacy database files
   - Add: `from core.database import get_core_db, get_analytics_db, get_cache_db`

4. **core/database/__init__.py** (cleanup):
   - Remove: `get_legacy_db()` function (line 67 per verification report)
   - Remove: Any compatibility shims for old database access
   - Keep: `get_core_db()`, `get_analytics_db()`, `get_cache_db()`

**Pattern for updates:**

Before:
```python
import sqlite3
conn = sqlite3.connect("data/llm_costs.db")
cursor = conn.cursor()
cursor.execute("INSERT INTO llm_usage ...")
```

After:
```python
from core.database import get_analytics_db
conn = get_analytics_db()
cursor = conn.cursor()
cursor.execute("INSERT INTO llm_usage ...")
```

Key principle: Minimal changes, same business logic, just swap database access method.

Gap reason from verification: "Only 3 files import from core.database, legacy imports still active"
  </action>
  <verify>grep -r "from core.database import get_" core/llm/cost_tracker.py core/monitoring/metrics_collector.py core/state_backup/state_backup.py</verify>
  <done>All P0 core/ files import from core.database, no hardcoded sqlite3.connect with paths</done>
</task>

<task type="auto">
  <name>Task 3: Update P1 bots/ files to use unified layer</name>
  <files>bots/treasury/trading.py, bots/buy_tracker/buy_bot.py</files>
  <action>
Update high-priority bots/ files that handle trades and positions:

1. **bots/treasury/trading.py** (3,754 lines per ROADMAP):
   - Scan for database access patterns (likely uses jarvis.db for positions/trades)
   - Replace with: `from core.database import get_core_db`
   - Update: All position and trade operations use `conn = get_core_db()`
   - Test: Ensure trades still execute correctly

2. **bots/buy_tracker/buy_bot.py** (if uses databases):
   - Check if it accesses databases directly
   - Update to use unified layer if needed
   - Skip if already using unified layer or no database access

**Approach for large files (trading.py):**
- Search for all `sqlite3.connect` calls
- Replace each with appropriate `get_X_db()` call
- Group related database operations to minimize connection churn
- Keep transaction boundaries intact

**Testing after update:**
- Run quick smoke test: Can the bot load positions?
- Verify no import errors
- Check that database connection pooling works

Gap items addressed:
- "Unknown status in bots/ and tg_bot/"
- Ensure critical trading paths use unified layer
  </action>
  <verify>grep -r "from core.database import get_core_db" bots/treasury/trading.py</verify>
  <done>bots/treasury/trading.py uses unified layer for all database access, no hardcoded paths</done>
</task>

<task type="auto">
  <name>Task 4: Create migration guide for developers</name>
  <files>.planning/phases/01-database-consolidation/01-03-MIGRATION-GUIDE.md</files>
  <action>
Create a developer migration guide documenting the unified database layer:

**Guide sections:**

1. **Overview**:
   - Why we consolidated (28→3 databases)
   - Benefits (connection pooling, atomic transactions, memory reduction)

2. **Migration patterns**:

   **Pattern 1: Core operational data**
   ```python
   # OLD
   import sqlite3
   conn = sqlite3.connect("data/jarvis.db")

   # NEW
   from core.database import get_core_db
   conn = get_core_db()
   ```

   **Pattern 2: Analytics/metrics data**
   ```python
   # OLD
   conn = sqlite3.connect("data/llm_costs.db")

   # NEW
   from core.database import get_analytics_db
   conn = get_analytics_db()
   ```

   **Pattern 3: Cache/ephemeral data**
   ```python
   # OLD
   conn = sqlite3.connect("data/rate_limiter.db")

   # NEW
   from core.database import get_cache_db
   conn = get_cache_db()
   ```

3. **Database mapping**:
   - Table showing which legacy DB → which consolidated DB
   - Table showing which table → which consolidated DB

4. **Breaking changes**:
   - Legacy database files will be removed after migration
   - `get_legacy_db()` function removed
   - Direct sqlite3.connect with paths is deprecated

5. **Testing checklist**:
   - Verify imports work
   - Check connection pooling active
   - Run integration tests
   - Monitor memory usage

6. **Rollback procedure** (if needed):
   - Restore legacy databases from backup
   - Revert code changes
   - Restart services

Save to: .planning/phases/01-database-consolidation/01-03-MIGRATION-GUIDE.md

Gap item addressed: "Add migration guide for developers"
  </action>
  <verify>test -f .planning/phases/01-database-consolidation/01-03-MIGRATION-GUIDE.md</verify>
  <done>Migration guide exists with patterns, mappings, and testing checklist</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Import verification**:
   ```bash
   # Should find many results (high adoption)
   grep -r "from core.database import" --include="*.py" core/ bots/ tg_bot/ | wc -l

   # Should find zero results (no legacy imports)
   grep -r "sqlite3.connect.*data/" --include="*.py" core/ bots/ tg_bot/ | wc -l
   ```

2. **Unified layer adoption**:
   ```bash
   # Check that core files use unified layer
   grep "from core.database import" core/llm/cost_tracker.py
   grep "from core.database import" bots/treasury/trading.py
   ```

3. **Legacy function removal**:
   ```bash
   # Should return no results
   grep "get_legacy_db" core/database/__init__.py
   ```

4. **No hardcoded paths**:
   ```bash
   # Should return zero results (or only test/migration files)
   grep -r "jarvis\.db\|llm_costs\.db" --include="*.py" core/ bots/ tg_bot/
   ```

5. **Documentation check**:
   - Audit report exists with file categorization
   - Migration guide exists with clear patterns
</verification>

<success_criteria>
- 15+ files import from core.database (up from 3)
- Zero hardcoded database paths in core/ production code
- core/llm/cost_tracker.py uses get_analytics_db()
- bots/treasury/trading.py uses get_core_db()
- get_legacy_db() function removed from core/database/__init__.py
- Migration guide exists for developers
- All updated files pass import checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-consolidation/01-03-SUMMARY.md` with:
- Files updated per category (P0, P1, P2)
- Before/after import statistics
- Any files skipped and why
- Testing results
- Migration guide location
</output>
