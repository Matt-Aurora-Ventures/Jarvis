---
phase: 06-memory-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/memory/__init__.py
  - core/memory/workspace.py
  - core/memory/config.py
autonomous: true

must_haves:
  truths:
    - "Memory workspace exists at ~/jarvis/memory/ with all required subdirectories"
    - "Configuration loads memory paths from environment or defaults"
    - "Workspace initializes idempotently (safe to call multiple times)"
  artifacts:
    - path: "core/memory/workspace.py"
      provides: "Workspace initialization and directory structure"
      exports: ["init_workspace", "get_memory_path", "MEMORY_ROOT"]
    - path: "core/memory/config.py"
      provides: "Memory configuration with environment overrides"
      exports: ["MemoryConfig", "get_config"]
  key_links:
    - from: "core/memory/workspace.py"
      to: "~/jarvis/memory/"
      via: "os.makedirs"
      pattern: "makedirs.*memory"
---

<objective>
Create the unified memory workspace directory structure at ~/jarvis/memory/ with all required subdirectories for the dual-layer Markdown + SQLite architecture.

Purpose: Establish the physical file system foundation that all subsequent memory operations depend on. This follows the Clawdbot architecture pattern with memory/, bank/, and entities/ subdirectories.

Output:
- core/memory/workspace.py with init_workspace() function
- core/memory/config.py with MemoryConfig dataclass
- Directory structure created at ~/jarvis/memory/
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/memory-integration/PROJECT.md
@.planning/memory-integration/ROADMAP.md
@.planning/memory-integration/STATE.md
@.planning/memory-integration/phases/06-memory-foundation/06-RESEARCH.md

Reference architecture from PROJECT.md:
```
~/jarvis/memory/               # Memory workspace root
├── memory.md                  # Core durable facts
├── memory/
│   ├── YYYY-MM-DD.md         # Daily session logs
│   └── archives/             # Older logs
├── bank/
│   ├── world.md              # Objective facts
│   ├── experience.md         # Agent experiences
│   ├── opinions.md           # Preferences with confidence
│   └── entities/             # Per-entity summaries
│       ├── tokens/
│       ├── users/
│       └── strategies/
├── jarvis.db                  # SQLite memory database
├── SOUL.md                   # Agent personality
├── AGENTS.md                 # Operating instructions
└── USER.md                   # User profile
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory configuration module</name>
  <files>core/memory/__init__.py, core/memory/config.py</files>
  <action>
Create the core/memory/ package with configuration management.

1. Create core/memory/__init__.py:
```python
"""Jarvis Memory System - Clawdbot-inspired dual-layer memory architecture."""
from .config import MemoryConfig, get_config
from .workspace import init_workspace, get_memory_path, MEMORY_ROOT

__all__ = [
    "MemoryConfig",
    "get_config",
    "init_workspace",
    "get_memory_path",
    "MEMORY_ROOT",
]
```

2. Create core/memory/config.py:
```python
"""Memory system configuration with environment overrides."""
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

@dataclass
class MemoryConfig:
    """Configuration for the Jarvis memory system."""

    # Root directory for memory workspace
    memory_root: Path = field(default_factory=lambda: Path.home() / "jarvis" / "memory")

    # SQLite database filename
    db_name: str = "jarvis.db"

    # PostgreSQL connection (from environment)
    postgres_url: Optional[str] = field(default_factory=lambda: os.getenv("DATABASE_URL"))

    # Daily log archival threshold (days)
    archive_after_days: int = 30

    # FTS5 tokenizer configuration
    fts_tokenizer: str = "porter unicode61"

    # WAL mode for concurrent access
    enable_wal: bool = True

    # Embedding model (for PostgreSQL integration)
    embedding_model: str = "BAAI/bge-large-en-v1.5"

    @property
    def db_path(self) -> Path:
        """Full path to SQLite database."""
        return self.memory_root / self.db_name

    @property
    def daily_logs_dir(self) -> Path:
        """Directory for daily session logs."""
        return self.memory_root / "memory"

    @property
    def archives_dir(self) -> Path:
        """Directory for archived logs."""
        return self.memory_root / "memory" / "archives"

    @property
    def bank_dir(self) -> Path:
        """Directory for knowledge bank."""
        return self.memory_root / "bank"

    @property
    def entities_dir(self) -> Path:
        """Directory for entity profiles."""
        return self.memory_root / "bank" / "entities"


_config: Optional[MemoryConfig] = None


def get_config() -> MemoryConfig:
    """Get or create the global memory configuration."""
    global _config
    if _config is None:
        # Allow environment override for memory root
        root_override = os.getenv("JARVIS_MEMORY_ROOT")
        if root_override:
            _config = MemoryConfig(memory_root=Path(root_override))
        else:
            _config = MemoryConfig()
    return _config
```
  </action>
  <verify>
```bash
python -c "from core.memory.config import MemoryConfig, get_config; c = get_config(); print(f'Memory root: {c.memory_root}'); print(f'DB path: {c.db_path}')"
```
Should print paths without errors.
  </verify>
  <done>MemoryConfig dataclass exists with all path properties, get_config() returns singleton instance</done>
</task>

<task type="auto">
  <name>Task 2: Create workspace initialization module</name>
  <files>core/memory/workspace.py</files>
  <action>
Create workspace.py with idempotent directory initialization.

```python
"""Memory workspace initialization and path utilities."""
import os
from datetime import datetime
from pathlib import Path
from typing import Optional

from .config import get_config, MemoryConfig

# Convenience export
MEMORY_ROOT: Optional[Path] = None


def init_workspace(config: Optional[MemoryConfig] = None) -> Path:
    """
    Initialize the memory workspace directory structure.

    Creates all required directories and placeholder files.
    Safe to call multiple times (idempotent).

    Args:
        config: Optional config override. Uses get_config() if not provided.

    Returns:
        Path to the memory root directory.
    """
    global MEMORY_ROOT

    if config is None:
        config = get_config()

    root = config.memory_root
    MEMORY_ROOT = root

    # Create directory structure
    directories = [
        root,
        root / "memory",
        root / "memory" / "archives",
        root / "bank",
        root / "bank" / "entities",
        root / "bank" / "entities" / "tokens",
        root / "bank" / "entities" / "users",
        root / "bank" / "entities" / "strategies",
    ]

    for directory in directories:
        directory.mkdir(parents=True, exist_ok=True)

    # Create placeholder Markdown files if they don't exist
    placeholder_files = {
        root / "memory.md": _create_memory_md_content(),
        root / "bank" / "world.md": _create_world_md_content(),
        root / "bank" / "experience.md": _create_experience_md_content(),
        root / "bank" / "opinions.md": _create_opinions_md_content(),
        root / "SOUL.md": _create_soul_md_content(),
        root / "AGENTS.md": _create_agents_md_content(),
        root / "USER.md": _create_user_md_content(),
    }

    for filepath, content in placeholder_files.items():
        if not filepath.exists():
            filepath.write_text(content, encoding="utf-8")

    return root


def get_memory_path(relative_path: str) -> Path:
    """
    Get absolute path within the memory workspace.

    Args:
        relative_path: Path relative to memory root (e.g., "memory/2026-01-25.md")

    Returns:
        Absolute Path object.
    """
    config = get_config()
    return config.memory_root / relative_path


def get_daily_log_path(date: Optional[datetime] = None) -> Path:
    """
    Get path to daily log file for given date.

    Args:
        date: Date for log file. Defaults to today.

    Returns:
        Path to daily log Markdown file.
    """
    if date is None:
        date = datetime.utcnow()

    config = get_config()
    filename = date.strftime("%Y-%m-%d.md")
    return config.daily_logs_dir / filename


def _create_memory_md_content() -> str:
    """Template for core memory.md file."""
    return f"""# Jarvis Memory

Core durable facts synthesized from daily experiences.

*Last updated: {datetime.utcnow().strftime("%Y-%m-%d")}*

---

## Key Facts

*Facts will be added here during daily reflect operations.*

---

## Patterns

*Recurring patterns will be documented here.*
"""


def _create_world_md_content() -> str:
    """Template for bank/world.md."""
    return """# World Knowledge

Objective facts about the trading world.

---

## Market Facts

*Market knowledge will be stored here.*

## Token Facts

*Token-specific knowledge will be stored here.*
"""


def _create_experience_md_content() -> str:
    """Template for bank/experience.md."""
    return """# Trading Experience

Lessons learned from trade outcomes.

---

## Successful Patterns

*Patterns that led to profitable trades.*

## Failed Patterns

*Patterns to avoid based on losses.*
"""


def _create_opinions_md_content() -> str:
    """Template for bank/opinions.md."""
    return """# Opinions & Preferences

Confidence-weighted beliefs that evolve with evidence.

---

## Trading Preferences

| Preference | Value | Confidence | Evidence Count |
|------------|-------|------------|----------------|
| *Preferences will be added here* | | | |

## Market Opinions

*Evolving market opinions will be stored here.*
"""


def _create_soul_md_content() -> str:
    """Template for SOUL.md (Jarvis identity)."""
    return """# Jarvis Identity

## Core Purpose

Autonomous LifeOS trading and AI assistant running on Solana.

## Personality

- Analytical and data-driven
- Risk-aware but opportunity-seeking
- Evolves intelligence based on evidence
- Remembers everything relevant

## Values

- Protect user capital above all
- Learn from every trade outcome
- Provide honest analysis, even when bearish
- Maintain confidence levels on all opinions
"""


def _create_agents_md_content() -> str:
    """Template for AGENTS.md (operating instructions)."""
    return """# Operating Instructions

## Memory Operations

### Retain
Store every significant event:
- Trade outcomes (buy/sell with context)
- User preferences expressed
- Token intel discovered
- Post performance metrics

### Recall
Query memory before decisions:
- Similar past trades before entering position
- User preferences before responding
- Token history before scoring

### Reflect
Daily synthesis:
- Update core memory.md
- Evolve confidence scores
- Archive old logs
"""


def _create_user_md_content() -> str:
    """Template for USER.md (primary user profile)."""
    return """# User Profile: lucid

## Identity

- Primary Jarvis administrator
- Telegram: @lucid
- X/Twitter: @lucid (if linked)

## Preferences

*Preferences will be populated from stored data.*

## Trading Style

*Trading style will be inferred from behavior.*
"""
```
  </action>
  <verify>
```bash
python -c "
from core.memory.workspace import init_workspace, get_memory_path, get_daily_log_path
import os

root = init_workspace()
print(f'Workspace created at: {root}')
print(f'Exists: {root.exists()}')
print(f'Has memory subdir: {(root / \"memory\").exists()}')
print(f'Has bank subdir: {(root / \"bank\").exists()}')
print(f'Has entities: {(root / \"bank\" / \"entities\" / \"tokens\").exists()}')
print(f'memory.md exists: {(root / \"memory.md\").exists()}')
print(f'Daily log path: {get_daily_log_path()}')
"
```
Should show all directories exist and memory.md was created.
  </verify>
  <done>
- init_workspace() creates ~/jarvis/memory/ with all subdirectories
- Placeholder Markdown files created (memory.md, bank/*.md, SOUL.md, etc.)
- get_memory_path() and get_daily_log_path() utility functions work
- Function is idempotent (safe to call multiple times)
  </done>
</task>

</tasks>

<verification>
1. Run the module import test:
```bash
python -c "from core.memory import init_workspace, get_config; init_workspace(); print('SUCCESS')"
```

2. Verify directory structure:
```bash
ls -la ~/jarvis/memory/
ls -la ~/jarvis/memory/memory/
ls -la ~/jarvis/memory/bank/
ls -la ~/jarvis/memory/bank/entities/
```

3. Verify placeholder files:
```bash
head -5 ~/jarvis/memory/memory.md
head -5 ~/jarvis/memory/SOUL.md
```
</verification>

<success_criteria>
- core/memory/ package imports without errors
- ~/jarvis/memory/ directory exists with all subdirectories
- All placeholder Markdown files created with correct templates
- get_config() returns MemoryConfig with correct paths
- init_workspace() is idempotent (multiple calls don't fail or duplicate content)
- Environment variable JARVIS_MEMORY_ROOT overrides default path
</success_criteria>

<output>
After completion, create `.planning/memory-integration/phases/06-memory-foundation/06-01-SUMMARY.md`
</output>
