---
phase: 07-retain-recall-functions
plan: 04
type: execute
wave: 3
depends_on: ["07-01"]
files_modified:
  - tg_bot/services/memory_service.py
  - tg_bot/services/chat_responder.py
autonomous: true

must_haves:
  truths:
    - "User preferences are stored from Telegram conversations"
    - "Preferences have confidence scores that evolve with evidence"
    - "Chat responses are personalized based on recalled preferences"
    - "get_user_preferences() returns all preferences for a user"
    - "Preference mentions in messages trigger retain_preference()"
  artifacts:
    - path: "tg_bot/services/memory_service.py"
      provides: "Telegram-specific memory integration"
      exports: ["store_user_preference", "get_user_context", "personalize_response"]
  key_links:
    - from: "tg_bot/services/chat_responder.py"
      to: "tg_bot/services/memory_service.py"
      via: "personalize_response() before sending"
      pattern: "personalize_response\\("
    - from: "tg_bot/services/memory_service.py"
      to: "core/memory/retain.py"
      via: "retain_preference() for storage"
      pattern: "retain_preference\\("
---

<objective>
Integrate memory retain/recall into Telegram bot for user preference storage and personalized responses.

Purpose: Telegram bot should learn user preferences from conversations (risk tolerance, favorite tokens, communication style) and use them to personalize responses. Preferences evolve with evidence - repeated mentions increase confidence.

Output:
- tg_bot/services/memory_service.py with preference management functions
- Integration in chat_responder.py for automatic preference detection and personalization
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/memory-integration/ROADMAP.md
@.planning/memory-integration/phases/07-retain-recall-functions/07-RESEARCH.md

# Phase 7 Wave 1 outputs
@core/memory/recall.py - Provides recall() function (created in 07-01)

# Existing Telegram code
@tg_bot/services/chat_responder.py - Chat response handling
@core/memory/retain.py - retain_preference(), get_user_preferences()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram memory service module</name>
  <files>tg_bot/services/memory_service.py</files>
  <action>
    Create tg_bot/services/memory_service.py for Telegram-specific memory integration:

    1. Import required modules:
       ```python
       from core.memory import retain_preference, retain_fact, recall, get_user_preferences
       from core.memory import save_session_context, get_session_context
       import re
       import logging
       ```

    2. Define preference patterns to detect in messages:
       ```python
       PREFERENCE_PATTERNS = {
           "risk_tolerance": [
               (r"(?:i\s+)?prefer\s+(?:high|more)\s+risk", "high"),
               (r"(?:i\s+)?prefer\s+(?:low|less)\s+risk", "low"),
               (r"(?:i\'m|i\s+am)\s+(?:a\s+)?conservative", "low"),
               (r"(?:i\'m|i\s+am)\s+(?:a\s+)?aggressive", "high"),
           ],
           "favorite_tokens": [
               (r"(?:i\s+)?(?:like|love|prefer)\s+\$?([A-Z]{3,6})", None),  # Extract token
           ],
           "communication_style": [
               (r"(?:be\s+)?(?:more\s+)?brief", "brief"),
               (r"(?:be\s+)?(?:more\s+)?detailed", "detailed"),
               (r"keep\s+it\s+(?:short|simple)", "brief"),
           ],
       }
       ```

    3. Implement detect_preferences():
       ```python
       def detect_preferences(message_text: str) -> List[Tuple[str, str, str]]:
           """
           Detect preference expressions in message.

           Returns:
               List of (preference_key, preference_value, matched_text)
           """
       ```

    4. Implement store_user_preference():
       ```python
       async def store_user_preference(
           user_id: str,
           preference_key: str,
           preference_value: str,
           evidence: str,  # The message that triggered this
           platform: str = "telegram",
       ) -> bool:
           """
           Store user preference with evidence for confidence evolution.
           """
       ```

    5. Implement get_user_context():
       ```python
       async def get_user_context(
           user_id: str,
           platform: str = "telegram",
       ) -> Dict[str, Any]:
           """
           Get full user context for personalization.

           Returns:
               {
                   "preferences": Dict[str, Any],  # All preferences with confidence
                   "recent_topics": List[str],  # Last 5 conversation topics
                   "session": Dict[str, Any],  # Current session context
               }
           """
       ```

    6. Implement personalize_response():
       ```python
       async def personalize_response(
           base_response: str,
           user_id: str,
           platform: str = "telegram",
       ) -> str:
           """
           Personalize response based on user preferences.

           Applies:
           - Communication style (brief/detailed)
           - Token preferences (highlight favorites)
           - Risk tolerance (adjust recommendations)
           """
       ```

    7. Implement store_conversation_fact():
       ```python
       async def store_conversation_fact(
           user_id: str,
           message_text: str,
           response_text: str,
           topic: Optional[str] = None,
       ) -> int:
           """
           Store conversation exchange as a fact for context.
           """
       ```

    Do NOT over-engineer preference detection - simple patterns work.
    Do NOT personalize aggressively - subtle adjustments only.
  </action>
  <verify>
    ```python
    # Test memory service
    from tg_bot.services.memory_service import (
        detect_preferences,
        store_user_preference,
        get_user_context,
        personalize_response
    )
    import asyncio

    async def test():
        # Detect preferences
        prefs = detect_preferences("I prefer high risk trades and love $SOL")
        print(f"Detected preferences: {prefs}")
        assert len(prefs) >= 1

        # Store preference
        result = await store_user_preference(
            user_id="12345",
            preference_key="risk_tolerance",
            preference_value="high",
            evidence="User said: I prefer high risk trades"
        )
        assert result == True

        # Get user context
        ctx = await get_user_context("12345")
        assert "preferences" in ctx

        print("Memory service working!")

    asyncio.run(test())
    ```
  </verify>
  <done>Telegram memory service created with preference detection, storage, and personalization</done>
</task>

<task type="auto">
  <name>Task 2: Integrate memory service into chat_responder.py</name>
  <files>tg_bot/services/chat_responder.py</files>
  <action>
    Integrate memory service into existing chat responder:

    1. Add imports at top of file:
       ```python
       from tg_bot.services.memory_service import (
           detect_preferences,
           store_user_preference,
           get_user_context,
           personalize_response,
           store_conversation_fact,
       )
       from core.async_utils import fire_and_forget
       ```

    2. Find the main response handler (likely respond(), handle_message(), or similar)

    3. Add preference detection before generating response:
       ```python
       # Detect and store preferences from user message
       detected_prefs = detect_preferences(message.text)
       for pref_key, pref_value, matched_text in detected_prefs:
           fire_and_forget(
               store_user_preference(
                   user_id=str(message.from_user.id),
                   preference_key=pref_key,
                   preference_value=pref_value,
                   evidence=f"User said: {message.text}"
               ),
               name=f"store_pref_{pref_key}"
           )
       ```

    4. Add context retrieval for personalization:
       ```python
       # Get user context for personalization
       user_context = await get_user_context(str(message.from_user.id))
       ```

    5. Add response personalization before sending:
       ```python
       # Personalize response based on preferences
       personalized = await personalize_response(
           base_response=response_text,
           user_id=str(message.from_user.id)
       )
       ```

    6. Add conversation storage after response:
       ```python
       # Store conversation for context (fire-and-forget)
       fire_and_forget(
           store_conversation_fact(
               user_id=str(message.from_user.id),
               message_text=message.text,
               response_text=personalized
           ),
           name="store_conversation"
       )
       ```

    7. Add environment variable for memory integration:
       ```python
       TELEGRAM_MEMORY_ENABLED = os.getenv("TELEGRAM_MEMORY_ENABLED", "true").lower() == "true"
       ```

    Look for: respond(), handle_message(), process_message(), on_message()
    Look for: where responses are generated and sent

    Do NOT change the core response logic - wrap with memory functions.
    Do NOT make memory errors block responses - use fire-and-forget.
    Do NOT over-personalize - keep changes subtle.
  </action>
  <verify>
    ```bash
    # Verify integration
    cd "c:\Users\lucid\OneDrive\Desktop\Projects\Jarvis"
    python -c "from tg_bot.services.chat_responder import *; print('Import OK')"

    # Check memory service imports
    python -c "
    with open('tg_bot/services/chat_responder.py') as f:
        content = f.read()
    assert 'memory_service' in content, 'memory_service not imported'
    assert 'detect_preferences' in content or 'get_user_context' in content, 'memory not used'
    print('Memory service integrated!')
    "
    ```
  </verify>
  <done>chat_responder.py detects preferences, retrieves context, and personalizes responses</done>
</task>

</tasks>

<verification>
1. Import test: `from tg_bot.services.memory_service import detect_preferences, get_user_context`
2. Preference detection: detect_preferences("I prefer high risk") returns preferences
3. Storage: store_user_preference() creates preference with confidence
4. Context retrieval: get_user_context() returns preferences and session
5. Personalization: personalize_response() adjusts response based on preferences
6. Integration: chat_responder.py uses memory service functions
7. Fire-and-forget: Memory operations don't block responses
</verification>

<success_criteria>
- Preference expressions detected from messages (risk, tokens, style)
- Preferences stored with confidence evolution
- get_user_context() returns all known preferences
- Responses personalized based on preferences
- Conversations stored for context
- Memory operations non-blocking
</success_criteria>

<output>
After completion, create `.planning/memory-integration/phases/07-retain-recall-functions/07-04-SUMMARY.md`
</output>
