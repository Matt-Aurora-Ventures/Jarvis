---
phase: 07-retain-recall-functions
plan: 05
type: execute
wave: 3
depends_on: ["07-01"]
files_modified:
  - bots/twitter/memory_hooks.py
  - bots/twitter/autonomous_engine.py
  - bots/bags_intel/memory_hooks.py
  - bots/bags_intel/intel_service.py
  - bots/buy_tracker/memory_hooks.py
autonomous: true

must_haves:
  truths:
    - "X/Twitter bot stores post performance (likes, retweets, replies)"
    - "X/Twitter bot recalls high-engagement patterns before posting"
    - "Bags Intel stores graduation patterns with token outcomes"
    - "Bags Intel queries historical success rates before scoring tokens"
    - "Buy Tracker stores purchase events for tracking"
  artifacts:
    - path: "bots/twitter/memory_hooks.py"
      provides: "X/Twitter memory integration"
      exports: ["store_post_performance", "recall_engagement_patterns"]
    - path: "bots/bags_intel/memory_hooks.py"
      provides: "Bags Intel memory integration"
      exports: ["store_graduation_outcome", "recall_similar_graduations"]
    - path: "bots/buy_tracker/memory_hooks.py"
      provides: "Buy Tracker memory integration"
      exports: ["store_purchase_event"]
  key_links:
    - from: "bots/twitter/autonomous_engine.py"
      to: "bots/twitter/memory_hooks.py"
      via: "fire_and_forget(store_post_performance())"
      pattern: "store_post_performance\\("
    - from: "bots/bags_intel/intel_service.py"
      to: "bots/bags_intel/memory_hooks.py"
      via: "recall_similar_graduations() before scoring"
      pattern: "recall_similar_graduations\\("
---

<objective>
Integrate memory retain/recall into X/Twitter bot, Bags Intel, and Buy Tracker for comprehensive bot memory.

Purpose: Complete the memory integration across all 5 Jarvis bot systems. X bot learns from post engagement, Bags Intel learns from graduation patterns, and Buy Tracker stores purchase history for analysis.

Output:
- bots/twitter/memory_hooks.py with post performance tracking
- bots/bags_intel/memory_hooks.py with graduation pattern storage
- bots/buy_tracker/memory_hooks.py with purchase tracking
- Integration points in respective bot engines
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/memory-integration/ROADMAP.md
@.planning/memory-integration/phases/07-retain-recall-functions/07-RESEARCH.md

# Phase 7 Wave 1 outputs
@core/memory/recall.py - Provides recall() function (created in 07-01)

# Existing bot code
@bots/twitter/autonomous_engine.py - Autonomous X posting engine
@bots/bags_intel/intel_service.py - Bags Intel service
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create X/Twitter memory hooks</name>
  <files>bots/twitter/memory_hooks.py, bots/twitter/autonomous_engine.py</files>
  <action>
    Create bots/twitter/memory_hooks.py for X/Twitter memory integration:

    1. Import required modules:
       ```python
       from core.async_utils import fire_and_forget, TaskTracker
       from core.memory import retain_fact, recall
       import logging
       ```

    2. Create module-level TaskTracker:
       ```python
       _memory_tracker = TaskTracker("twitter_memory")
       ```

    3. Implement store_post_performance():
       ```python
       async def store_post_performance(
           tweet_id: str,
           content: str,
           likes: int,
           retweets: int,
           replies: int,
           impressions: Optional[int] = None,
           topic: Optional[str] = None,
           posting_time: Optional[datetime] = None,
       ) -> int:
           """
           Store X post performance metrics.

           Creates fact with:
           - content: Post content and engagement summary
           - context: "post_performance|{tweet_id}"
           - entities: [topic if any, @mentions from content]
           - source: "x_posting"
           - metadata: Full metrics
           """
       ```

    4. Implement recall_engagement_patterns():
       ```python
       async def recall_engagement_patterns(
           topic: Optional[str] = None,
           min_likes: int = 10,
           k: int = 10,
       ) -> List[Dict[str, Any]]:
           """
           Recall high-engagement posts for pattern learning.

           Returns posts sorted by engagement score.
           """
       ```

    5. Implement get_best_posting_times():
       ```python
       async def get_best_posting_times(
           k: int = 5,
       ) -> List[Dict[str, Any]]:
           """
           Analyze past posts to find best posting times.

           Returns list of (hour, avg_engagement) sorted by engagement.
           """
       ```

    6. Implement suggest_content_patterns():
       ```python
       async def suggest_content_patterns() -> Dict[str, Any]:
           """
           Analyze high-performing posts for content patterns.

           Returns:
               {
                   "high_engagement_topics": List[str],
                   "avg_engagement_by_topic": Dict[str, float],
                   "best_performing_posts": List[Dict],
               }
           """
       ```

    7. Integrate into autonomous_engine.py:
       - Add import for memory_hooks
       - After posting: fire_and_forget(store_post_performance(...))
       - Before posting: Call recall_engagement_patterns() to inform content
       - Add TWITTER_MEMORY_ENABLED env var check

    Find in autonomous_engine.py: post_tweet(), send_tweet(), or similar
    Find: where engagement metrics are available (might need to fetch later)

    Do NOT block posting on memory operations.
    Do NOT change core posting logic - add memory alongside.
  </action>
  <verify>
    ```python
    # Test X memory hooks
    from bots.twitter.memory_hooks import (
        store_post_performance,
        recall_engagement_patterns,
        suggest_content_patterns
    )
    import asyncio

    async def test():
        # Store post performance
        fact_id = await store_post_performance(
            tweet_id="123456",
            content="Solana is pumping! $SOL to the moon!",
            likes=50,
            retweets=10,
            replies=5,
            topic="market_sentiment"
        )
        assert fact_id > 0

        # Recall patterns
        patterns = await recall_engagement_patterns(min_likes=5)
        assert isinstance(patterns, list)

        print("X memory hooks working!")

    asyncio.run(test())
    ```
  </verify>
  <done>X/Twitter memory hooks created and integrated with autonomous_engine.py</done>
</task>

<task type="auto">
  <name>Task 2: Create Bags Intel memory hooks</name>
  <files>bots/bags_intel/memory_hooks.py, bots/bags_intel/intel_service.py</files>
  <action>
    Create bots/bags_intel/memory_hooks.py for graduation pattern tracking:

    1. Import required modules:
       ```python
       from core.async_utils import fire_and_forget, TaskTracker
       from core.memory import retain_fact, recall
       import logging
       ```

    2. Create module-level TaskTracker:
       ```python
       _memory_tracker = TaskTracker("bags_intel_memory")
       ```

    3. Implement store_graduation_outcome():
       ```python
       async def store_graduation_outcome(
           token_symbol: str,
           token_mint: str,
           graduation_score: float,  # 0-100 from intel_service
           price_at_graduation: float,
           price_24h_later: Optional[float] = None,
           price_7d_later: Optional[float] = None,
           outcome: Optional[str] = None,  # success, failure, pending
           creator_twitter: Optional[str] = None,
           bonding_curve_data: Optional[Dict] = None,
       ) -> int:
           """
           Store graduation event and outcome.

           Creates fact with:
           - content: Graduation summary with score and outcome
           - context: "graduation_outcome|{token_mint}"
           - entities: [@token_symbol, @creator if known]
           - source: "bags_intel"
           - metadata: Full graduation data
           """
       ```

    4. Implement recall_similar_graduations():
       ```python
       async def recall_similar_graduations(
           score_range: Tuple[float, float] = (0, 100),
           creator_twitter: Optional[str] = None,
           k: int = 10,
       ) -> List[Dict[str, Any]]:
           """
           Recall similar past graduations for pattern matching.

           Used to predict success of new graduations.
           """
       ```

    5. Implement get_graduation_success_rate():
       ```python
       async def get_graduation_success_rate(
           score_threshold: float = 70,
           days: int = 30,
       ) -> Dict[str, Any]:
           """
           Calculate historical success rate for high-score graduations.

           Returns:
               {
                   "total_graduations": int,
                   "successful": int,
                   "success_rate": float,
                   "avg_score_successful": float,
                   "avg_score_failed": float,
               }
           """
       ```

    6. Implement predict_graduation_success():
       ```python
       async def predict_graduation_success(
           score: float,
           creator_twitter: Optional[str] = None,
       ) -> Tuple[float, str]:
           """
           Predict success probability based on historical patterns.

           Returns:
               (probability, reasoning)
           """
       ```

    7. Integrate into intel_service.py:
       - Add import for memory_hooks
       - After scoring: fire_and_forget(store_graduation_outcome(...))
       - During scoring: Call recall_similar_graduations() to inform predictions
       - Add BAGS_INTEL_MEMORY_ENABLED env var check

    Find in intel_service.py: score_token(), analyze_graduation(), process_graduation()

    Do NOT block scoring on memory operations.
    Do NOT change existing scoring logic - add memory insights alongside.
  </action>
  <verify>
    ```python
    # Test Bags Intel memory hooks
    from bots.bags_intel.memory_hooks import (
        store_graduation_outcome,
        recall_similar_graduations,
        get_graduation_success_rate
    )
    import asyncio

    async def test():
        # Store graduation
        fact_id = await store_graduation_outcome(
            token_symbol="TEST",
            token_mint="test123",
            graduation_score=75.5,
            price_at_graduation=0.001,
            outcome="pending"
        )
        assert fact_id > 0

        # Recall similar
        similar = await recall_similar_graduations(score_range=(70, 80))
        assert isinstance(similar, list)

        print("Bags Intel memory hooks working!")

    asyncio.run(test())
    ```
  </verify>
  <done>Bags Intel memory hooks created and integrated with intel_service.py</done>
</task>

<task type="auto">
  <name>Task 3: Create Buy Tracker memory hooks</name>
  <files>bots/buy_tracker/memory_hooks.py</files>
  <action>
    Create bots/buy_tracker/memory_hooks.py for purchase event tracking:

    1. First, find the Buy Tracker main file:
       - Check bots/buy_tracker/ for main module
       - If buy_bot.py doesn't exist, find the equivalent (tracker.py, monitor.py, etc.)

    2. Import required modules:
       ```python
       from core.async_utils import fire_and_forget, TaskTracker
       from core.memory import retain_fact, recall
       import logging
       ```

    3. Create module-level TaskTracker:
       ```python
       _memory_tracker = TaskTracker("buy_tracker_memory")
       ```

    4. Implement store_purchase_event():
       ```python
       async def store_purchase_event(
           token_symbol: str,
           token_mint: str,
           buyer_wallet: str,
           purchase_amount_sol: float,
           token_amount: float,
           price_at_purchase: float,
           source: str = "kr8tiv",  # kr8tiv, whale_watch, etc.
           metadata: Optional[Dict] = None,
       ) -> int:
           """
           Store purchase event for tracking.

           Creates fact with:
           - content: Purchase summary
           - context: "purchase_event|{token_mint}"
           - entities: [@token_symbol, buyer wallet pattern]
           - source: "buy_tracker"
           - metadata: Full purchase data
           """
       ```

    5. Implement recall_purchase_history():
       ```python
       async def recall_purchase_history(
           token_symbol: Optional[str] = None,
           buyer_wallet: Optional[str] = None,
           k: int = 20,
       ) -> List[Dict[str, Any]]:
           """
           Recall purchase history for a token or wallet.
           """
       ```

    6. Implement get_token_buy_stats():
       ```python
       async def get_token_buy_stats(
           token_symbol: str,
           days: int = 7,
       ) -> Dict[str, Any]:
           """
           Get aggregated buy statistics for a token.

           Returns:
               {
                   "total_purchases": int,
                   "total_sol_volume": float,
                   "unique_buyers": int,
                   "avg_purchase_size": float,
                   "largest_purchase": float,
               }
           """
       ```

    7. Find and integrate with Buy Tracker main file (if it exists):
       - Add import for memory_hooks
       - After detecting purchase: fire_and_forget(store_purchase_event(...))
       - Add BUY_TRACKER_MEMORY_ENABLED env var check

    Note: Buy Tracker may have different file structure. Adapt as needed.

    Do NOT fail if Buy Tracker structure differs - create hooks module anyway.
    Do NOT block tracking on memory operations.
  </action>
  <verify>
    ```python
    # Test Buy Tracker memory hooks
    from bots.buy_tracker.memory_hooks import (
        store_purchase_event,
        recall_purchase_history,
        get_token_buy_stats
    )
    import asyncio

    async def test():
        # Store purchase
        fact_id = await store_purchase_event(
            token_symbol="KR8TIV",
            token_mint="kr8tiv123",
            buyer_wallet="abc...xyz",
            purchase_amount_sol=1.5,
            token_amount=1000000,
            price_at_purchase=0.0000015
        )
        assert fact_id > 0

        # Recall history
        history = await recall_purchase_history(token_symbol="KR8TIV")
        assert isinstance(history, list)

        print("Buy Tracker memory hooks working!")

    asyncio.run(test())
    ```
  </verify>
  <done>Buy Tracker memory hooks created for purchase event tracking</done>
</task>

</tasks>

<verification>
1. Import test for all three: twitter/memory_hooks, bags_intel/memory_hooks, buy_tracker/memory_hooks
2. X/Twitter: store_post_performance() creates post_performance facts
3. X/Twitter: recall_engagement_patterns() returns high-engagement posts
4. Bags Intel: store_graduation_outcome() creates graduation_outcome facts
5. Bags Intel: recall_similar_graduations() returns similar patterns
6. Buy Tracker: store_purchase_event() creates purchase_event facts
7. All: Memory operations are fire-and-forget (non-blocking)
</verification>

<success_criteria>
- X/Twitter bot stores post metrics after posting
- X/Twitter bot can recall high-engagement patterns
- Bags Intel stores graduation outcomes
- Bags Intel can recall similar graduations for predictions
- Buy Tracker stores purchase events
- All memory operations non-blocking
- Integration with respective bot engines complete
</success_criteria>

<output>
After completion, create `.planning/memory-integration/phases/07-retain-recall-functions/07-05-SUMMARY.md`
</output>
