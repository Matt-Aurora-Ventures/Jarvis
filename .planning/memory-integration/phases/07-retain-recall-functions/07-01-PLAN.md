---
phase: 07-retain-recall-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/memory/recall.py
  - core/memory/session.py
  - core/memory/__init__.py
autonomous: true

must_haves:
  truths:
    - "recall(query) returns relevant facts from memory"
    - "recall() completes in <100ms at p95 for typical queries"
    - "Temporal filters (today, week, month, all) work correctly"
    - "Session context can be saved and resumed across bot restarts"
  artifacts:
    - path: "core/memory/recall.py"
      provides: "Core recall() function with temporal filters"
      exports: ["recall", "recall_by_entity", "recall_recent"]
    - path: "core/memory/session.py"
      provides: "Session context persistence"
      exports: ["save_session_context", "get_session_context", "clear_session_context"]
  key_links:
    - from: "core/memory/recall.py"
      to: "core/memory/hybrid_search.py"
      via: "hybrid_search() for combined FTS5 + vector search"
      pattern: "hybrid_search\\("
    - from: "core/memory/session.py"
      to: "core/memory/database.py"
      via: "DatabaseManager for sessions table access"
      pattern: "get_db\\(\\)"
---

<objective>
Create the core recall() API for memory retrieval and session context management for conversation continuity.

Purpose: Provides the primary interface for all Jarvis bots to query past facts, trade outcomes, and user preferences. Session context enables bots to resume conversations across restarts.

Output:
- core/memory/recall.py with recall(), recall_by_entity(), recall_recent()
- core/memory/session.py with session persistence functions
- Exports added to core/memory/__init__.py
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/memory-integration/ROADMAP.md
@.planning/memory-integration/phases/07-retain-recall-functions/07-RESEARCH.md

# Phase 6 foundations (already built)
@core/memory/hybrid_search.py - Provides hybrid_search() with FTS5 + vector RRF
@core/memory/search.py - Provides search_facts(), search_by_entity()
@core/memory/database.py - Provides DatabaseManager with WAL mode
@core/memory/schema.py - Sessions table schema
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core recall() API</name>
  <files>core/memory/recall.py, core/memory/__init__.py</files>
  <action>
    Create core/memory/recall.py with user-friendly recall interface that wraps hybrid_search:

    1. Define recall() function with signature:
       ```python
       async def recall(
           query: str,
           k: int = 10,
           time_filter: str = "all",  # today, week, month, quarter, year, all
           source_filter: Optional[str] = None,  # treasury, telegram, x, bags_intel, buy_tracker
           context_filter: Optional[str] = None,  # trade_outcome, user_preference, etc.
           entity_filter: Optional[str] = None,  # @KR8TIV, @lucid
           confidence_min: float = 0.0,
           include_embeddings: bool = False,  # Whether to use vector search
       ) -> List[Dict[str, Any]]:
       ```

    2. Implement recall_by_entity() for entity-specific queries:
       ```python
       async def recall_by_entity(
           entity_name: str,
           k: int = 10,
           time_filter: str = "all",
       ) -> List[Dict[str, Any]]:
       ```

    3. Implement recall_recent() for quick access to recent facts:
       ```python
       async def recall_recent(
           k: int = 10,
           source_filter: Optional[str] = None,
       ) -> List[Dict[str, Any]]:
       ```

    4. Use asyncio.to_thread() to wrap synchronous hybrid_search() calls for async compatibility

    5. Return results as list of dicts with keys: id, content, context, source, timestamp, confidence, entities, relevance_score

    6. Add performance logging: log queries >100ms as warnings

    7. Export functions in core/memory/__init__.py

    Do NOT use blocking calls in async context. Use asyncio.to_thread() for sync operations.
    Do NOT create new database connections per query - use get_db() singleton.
  </action>
  <verify>
    ```python
    # Test recall API
    from core.memory import recall, recall_by_entity, recall_recent
    import asyncio

    async def test():
        # Basic query
        results = await recall("trading outcomes", k=5, time_filter="week")
        assert isinstance(results, list)

        # Entity query
        entity_results = await recall_by_entity("@KR8TIV", k=5)
        assert isinstance(entity_results, list)

        # Recent facts
        recent = await recall_recent(k=5)
        assert isinstance(recent, list)

        print("All recall functions working!")

    asyncio.run(test())
    ```
  </verify>
  <done>recall(), recall_by_entity(), recall_recent() functions work with proper async interface and return structured results</done>
</task>

<task type="auto">
  <name>Task 2: Add session context persistence</name>
  <files>core/memory/session.py, core/memory/__init__.py</files>
  <action>
    Create core/memory/session.py for cross-session context resumption:

    1. Implement save_session_context():
       ```python
       def save_session_context(
           user_id: str,
           platform: str,  # telegram, x, api
           context: Dict[str, Any],  # Current conversation state
           metadata: Optional[Dict[str, Any]] = None,
       ) -> int:  # Returns session_id
       ```

    2. Implement get_session_context():
       ```python
       def get_session_context(
           user_id: str,
           platform: str,
       ) -> Optional[Dict[str, Any]]:  # Returns None if no active session
       ```

    3. Implement clear_session_context():
       ```python
       def clear_session_context(
           user_id: str,
           platform: str,
       ) -> bool:
       ```

    4. Implement get_or_create_session():
       ```python
       def get_or_create_session(
           user_id: str,
           platform: str,
       ) -> Tuple[int, Dict[str, Any]]:  # Returns (session_id, context)
       ```

    5. Use existing sessions table from schema.py:
       - id, user_id, platform, started_at, last_activity, context (JSON), metadata (JSON)

    6. Update last_activity timestamp on each context save

    7. Store context as JSON in the context column

    8. Export functions in core/memory/__init__.py

    Do NOT create new table - use existing sessions table from Phase 6.
    Do NOT use ORM - use raw SQL via DatabaseManager.
  </action>
  <verify>
    ```python
    # Test session context
    from core.memory import save_session_context, get_session_context, clear_session_context

    # Save context
    session_id = save_session_context(
        user_id="123456",
        platform="telegram",
        context={"current_topic": "trading", "last_token": "KR8TIV"},
        metadata={"bot_version": "1.0"}
    )
    assert session_id > 0

    # Retrieve context
    ctx = get_session_context("123456", "telegram")
    assert ctx is not None
    assert ctx["current_topic"] == "trading"

    # Clear context
    cleared = clear_session_context("123456", "telegram")
    assert cleared == True

    print("Session context functions working!")
    ```
  </verify>
  <done>Session context can be saved, retrieved, and cleared. Context persists across bot restarts.</done>
</task>

</tasks>

<verification>
1. Import test: `from core.memory import recall, recall_by_entity, recall_recent, save_session_context, get_session_context`
2. Recall returns results: `await recall("test", k=5)` returns list
3. Session persistence: Context survives save/load cycle
4. Performance: recall() with 100 facts completes in <100ms
5. Temporal filters: time_filter="week" only returns facts from last 7 days
</verification>

<success_criteria>
- recall() function works with async interface
- All temporal filters (today, week, month, quarter, year, all) filter correctly
- Session context persists across function calls
- Performance target: <100ms for typical queries
- No blocking calls in async context
</success_criteria>

<output>
After completion, create `.planning/memory-integration/phases/07-retain-recall-functions/07-01-SUMMARY.md`
</output>
