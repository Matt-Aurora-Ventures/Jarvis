---
phase: 07-retain-recall-functions
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - bots/treasury/trading/trading_operations.py
  - bots/treasury/trading/memory_hooks.py
  - bots/treasury/trading/types.py
autonomous: true

must_haves:
  truths:
    - "Every trade close stores outcome in memory with fire-and-forget"
    - "Trade outcomes include token, entry/exit price, PnL%, hold duration, strategy"
    - "recall() is called before entering new positions to check historical performance"
    - "81+ trading strategies are tracked with performance metrics"
    - "Dual-write pattern: both .positions.json and memory system updated"
  artifacts:
    - path: "bots/treasury/trading/memory_hooks.py"
      provides: "Memory integration hooks for treasury trading"
      exports: ["store_trade_outcome", "recall_token_history", "should_enter_based_on_history"]
  key_links:
    - from: "bots/treasury/trading/trading_operations.py"
      to: "bots/treasury/trading/memory_hooks.py"
      via: "fire_and_forget(store_trade_outcome())"
      pattern: "fire_and_forget\\("
    - from: "bots/treasury/trading/memory_hooks.py"
      to: "core/memory/retain.py"
      via: "retain_fact() for trade storage"
      pattern: "retain_fact\\("
    - from: "bots/treasury/trading/memory_hooks.py"
      to: "core/memory/recall.py"
      via: "recall() for historical lookup"
      pattern: "recall\\("
---

<objective>
Integrate memory retain/recall into Treasury trading operations for trade outcome storage and history-informed decisions.

Purpose: Treasury bot should store every trade outcome with full context (token, price, sentiment, strategy, outcome) and query historical performance before entering new positions. This enables learning from past trades to improve future decisions.

Output:
- bots/treasury/trading/memory_hooks.py with trade memory functions
- Integration points in trading_operations.py for retain after trades
- Recall integration before position decisions
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/memory-integration/ROADMAP.md
@.planning/memory-integration/phases/07-retain-recall-functions/07-RESEARCH.md

# Phase 7 Wave 1 outputs
@core/memory/recall.py - Provides recall() function (created in 07-01)

# Existing Treasury code
@bots/treasury/trading/trading_operations.py - Main trading operations
@bots/treasury/trading/types.py - Position, TradeResult types
@core/async_utils.py - fire_and_forget(), TaskTracker
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Treasury memory hooks module</name>
  <files>bots/treasury/trading/memory_hooks.py</files>
  <action>
    Create bots/treasury/trading/memory_hooks.py with trade memory functions:

    1. Import required modules:
       ```python
       from core.async_utils import fire_and_forget, TaskTracker
       from core.memory import retain_fact, recall
       import asyncio
       import logging
       ```

    2. Create module-level TaskTracker:
       ```python
       _memory_tracker = TaskTracker("treasury_memory")
       ```

    3. Implement store_trade_outcome():
       ```python
       async def store_trade_outcome(
           token_symbol: str,
           token_mint: str,
           entry_price: float,
           exit_price: float,
           pnl_pct: float,
           hold_duration_hours: float,
           strategy: str,
           sentiment_score: Optional[float] = None,
           exit_reason: str = "manual",
           metadata: Optional[Dict[str, Any]] = None,
       ) -> int:
           """
           Store trade outcome in memory. Returns fact_id.

           Creates fact with:
           - content: Human-readable trade summary
           - context: "trade_outcome|{token_mint}"
           - entities: [@{token_symbol}, {strategy}]
           - source: "treasury_trading"
           - metadata: Full trade details as JSON
           """
       ```

    4. Implement recall_token_history():
       ```python
       async def recall_token_history(
           token_symbol: str,
           k: int = 20,
           days: int = 90,
       ) -> List[Dict[str, Any]]:
           """
           Recall past trades for a specific token.

           Returns list of past trade outcomes sorted by date desc.
           """
       ```

    5. Implement should_enter_based_on_history():
       ```python
       async def should_enter_based_on_history(
           token_symbol: str,
           min_win_rate: float = 0.3,
           min_trades: int = 3,
       ) -> Tuple[bool, str]:
           """
           Check if historical performance supports entering this token.

           Returns:
               (should_enter, reason)
               e.g., (False, "Low win rate: 25% (2W/6L)")
               e.g., (True, "Good history: 60% wins (6W/4L)")
               e.g., (True, "New token - no history")
           """
       ```

    6. Implement get_strategy_performance():
       ```python
       async def get_strategy_performance(
           strategy: str,
           days: int = 30,
       ) -> Dict[str, Any]:
           """
           Get performance metrics for a trading strategy.

           Returns:
               {
                   "strategy": str,
                   "trade_count": int,
                   "win_count": int,
                   "win_rate": float,
                   "avg_pnl": float,
                   "total_pnl": float,
               }
           """
       ```

    7. Implement list_all_strategies():
       ```python
       async def list_all_strategies() -> List[Dict[str, Any]]:
           """
           List all trading strategies with performance metrics.

           Returns list of strategy performance dicts.
           Supports 81+ strategies as per INT-005.
           """
       ```

    8. Add fire_and_forget wrapper for non-blocking storage:
       ```python
       def store_trade_outcome_async(
           token_symbol: str,
           # ... same params as store_trade_outcome
       ) -> asyncio.Task:
           """Fire-and-forget wrapper for store_trade_outcome"""
           return fire_and_forget(
               store_trade_outcome(token_symbol, ...),
               name=f"store_trade_{token_symbol}",
               tracker=_memory_tracker
           )
       ```

    Do NOT block on memory writes - always use fire_and_forget.
    Do NOT create new dependencies - use existing core.memory and core.async_utils.
  </action>
  <verify>
    ```python
    # Test memory hooks
    from bots.treasury.trading.memory_hooks import (
        store_trade_outcome,
        recall_token_history,
        should_enter_based_on_history,
        get_strategy_performance
    )
    import asyncio

    async def test():
        # Store a trade
        fact_id = await store_trade_outcome(
            token_symbol="TEST",
            token_mint="test123",
            entry_price=1.0,
            exit_price=1.15,
            pnl_pct=15.0,
            hold_duration_hours=2.5,
            strategy="momentum",
            sentiment_score=0.8,
            exit_reason="take_profit"
        )
        assert fact_id > 0

        # Recall history
        history = await recall_token_history("TEST", k=5)
        assert len(history) >= 1

        # Check if should enter
        should_enter, reason = await should_enter_based_on_history("TEST")
        print(f"Should enter: {should_enter}, Reason: {reason}")

        print("Treasury memory hooks working!")

    asyncio.run(test())
    ```
  </verify>
  <done>Treasury memory hooks module created with store_trade_outcome, recall_token_history, should_enter_based_on_history</done>
</task>

<task type="auto">
  <name>Task 2: Integrate memory hooks into trading_operations.py</name>
  <files>bots/treasury/trading/trading_operations.py</files>
  <action>
    Integrate memory hooks into existing trading operations:

    1. Add imports at top of file:
       ```python
       from bots.treasury.trading.memory_hooks import (
           store_trade_outcome_async,
           should_enter_based_on_history,
       )
       ```

    2. Find the close_position() or equivalent method and add fire-and-forget memory storage:
       - After successful trade close
       - Extract all relevant data: token, prices, PnL, duration, strategy
       - Call store_trade_outcome_async() with fire-and-forget pattern
       - Add logging: logger.info(f"Storing trade outcome for {token_symbol}")

    3. Find the position entry decision point and add recall check:
       - Before opening new position
       - Call should_enter_based_on_history()
       - Log the decision: logger.info(f"Historical check for {token}: {reason}")
       - If should_enter is False, log warning but don't block (configurable)

    4. Implement dual-write pattern:
       - Keep existing .positions.json write (for rollback safety)
       - Add memory system write in parallel
       - During Phase 7 both systems updated
       - Phase 8 will deprecate .positions.json writes

    5. Add environment variable for memory integration:
       ```python
       TREASURY_MEMORY_ENABLED = os.getenv("TREASURY_MEMORY_ENABLED", "true").lower() == "true"
       ```
       - Only call memory hooks if enabled
       - Default to enabled

    Look for methods like: close_position, sell_position, execute_exit, close_trade
    Look for position entry: open_position, buy_position, should_enter, execute_entry

    Do NOT remove existing functionality - add memory integration alongside.
    Do NOT make memory errors block trades - use fire-and-forget with error logging.
    Do NOT change the core trading logic - only add memory hooks.
  </action>
  <verify>
    ```bash
    # Verify integration
    cd "c:\Users\lucid\OneDrive\Desktop\Projects\Jarvis"
    python -c "from bots.treasury.trading.trading_operations import *; print('Import OK')"

    # Check memory hook imports
    python -c "
    import ast
    with open('bots/treasury/trading/trading_operations.py') as f:
        content = f.read()
    assert 'memory_hooks' in content, 'memory_hooks not imported'
    assert 'store_trade_outcome' in content or 'store_trade_outcome_async' in content, 'store not used'
    print('Memory hooks integrated!')
    "
    ```
  </verify>
  <done>trading_operations.py stores trade outcomes with fire-and-forget and optionally checks history before entry</done>
</task>

<task type="auto">
  <name>Task 3: Add strategy performance tracking</name>
  <files>bots/treasury/trading/memory_hooks.py, bots/treasury/trading/types.py</files>
  <action>
    Enhance strategy tracking to support 81+ strategies per INT-005:

    1. In memory_hooks.py, add strategy entity creation:
       ```python
       async def ensure_strategy_entity(strategy: str) -> None:
           """Create strategy entity if not exists"""
           from core.memory import get_entity_profile, create_entity_profile
           profile = get_entity_profile(strategy)
           if not profile:
               create_entity_profile(
                   entity_name=strategy,
                   entity_type="strategy",
                   summary=f"Trading strategy: {strategy}",
               )
       ```

    2. Update store_trade_outcome to call ensure_strategy_entity

    3. Add get_all_strategies_summary():
       ```python
       async def get_all_strategies_summary() -> str:
           """
           Get human-readable summary of all strategy performance.

           Returns markdown-formatted summary for Telegram/reporting.
           """
       ```

    4. In types.py, add StrategyPerformance dataclass if not exists:
       ```python
       @dataclass
       class StrategyPerformance:
           strategy: str
           trade_count: int
           win_count: int
           loss_count: int
           win_rate: float
           avg_pnl: float
           total_pnl: float
           best_trade_pnl: float
           worst_trade_pnl: float
           last_trade_date: Optional[datetime] = None
       ```

    5. Ensure all strategies get tracked as entities:
       - momentum, breakout, reversal, bags_graduation, etc.
       - New strategies auto-created on first trade

    Do NOT hardcode strategy list - discover from trades.
    Do NOT create complex strategy management - keep it simple.
  </action>
  <verify>
    ```python
    # Test strategy tracking
    from bots.treasury.trading.memory_hooks import (
        get_strategy_performance,
        list_all_strategies,
        ensure_strategy_entity
    )
    import asyncio

    async def test():
        # Ensure strategy exists
        await ensure_strategy_entity("momentum")

        # Get performance
        perf = await get_strategy_performance("momentum", days=30)
        assert "strategy" in perf
        assert "trade_count" in perf
        assert "win_rate" in perf

        # List all strategies
        strategies = await list_all_strategies()
        assert isinstance(strategies, list)

        print("Strategy tracking working!")

    asyncio.run(test())
    ```
  </verify>
  <done>Strategy performance tracking works for 81+ strategies with auto-discovery</done>
</task>

</tasks>

<verification>
1. Import test: `from bots.treasury.trading.memory_hooks import store_trade_outcome, recall_token_history`
2. Trade storage: store_trade_outcome() creates fact with trade_outcome context
3. History recall: recall_token_history() returns past trades
4. Decision support: should_enter_based_on_history() returns (bool, reason)
5. Strategy tracking: get_strategy_performance() returns metrics
6. Integration: trading_operations.py uses memory hooks
7. Fire-and-forget: Memory writes don't block trade execution
</verification>

<success_criteria>
- Every trade close stores outcome in memory
- Trade facts include: token, prices, PnL%, duration, strategy, sentiment
- recall_token_history() returns relevant past trades
- should_enter_based_on_history() provides decision support
- Strategy performance tracked across 81+ strategies
- Memory writes are fire-and-forget (non-blocking)
- Dual-write to both .positions.json and memory system
</success_criteria>

<output>
After completion, create `.planning/memory-integration/phases/07-retain-recall-functions/07-03-SUMMARY.md`
</output>
